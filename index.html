<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ–ç‰‡æ™ºæ…§å‰ªè£å·¥å…·</title>
    <!-- è¼‰å…¥ Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è¼‰å…¥ Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- è¼‰å…¥ JSZip for creating ZIP archives -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* è‡ªå®šç¾©æ¼¸å±¤èƒŒæ™¯ */
        .app-bg {
            background: linear-gradient(135deg, #4A90E2 0%, #50E3C2 100%);
            min-height: 100vh;
        }
        /* ç¢ºä¿å…§å®¹é ä¸Šå°é½Š */
        .content-container {
            padding-top: 20px;
        }
        /* Canvas å®¹å™¨æ¨£å¼ */
        #canvas-container {
            max-width: 100%;
            height: auto;
            position: relative;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .file-upload-label {
            transition: all 0.2s;
        }
        .file-upload-label:hover {
            box-shadow: 0 4px 15px rgba(50, 255, 200, 0.4);
            transform: translateY(-2px);
        }
        /* æ‹–æ›³é è¦½æ¡†æ¨£å¼ */
        #drag-preview {
            position: absolute;
            z-index: 50;
            pointer-events: none;
            display: none;
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #4A90E2;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        #previewCanvas {
            max-width: 100px;
            max-height: 100px;
            display: block;
        }
        /* ç„¡éšœç¤™ï¼šè¢å¹•é–±è®€å™¨å°ˆç”¨ */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'Noto Sans TC', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="font-sans app-bg">
    
    <!-- å°è¦½åˆ— -->
    <header class="bg-white/90 shadow-md sticky top-0 z-10">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 flex justify-between items-center">
            <h1 class="text-xl sm:text-2xl font-bold text-gray-800">åœ–ç‰‡æ™ºæ…§å‰ªè£å·¥å…·</h1>
            <div class="flex items-center space-x-4">
                <button id="saveSettingsBtn" title="å„²å­˜ç•¶å‰è¨­å®š" class="hidden text-blue-600 hover:text-blue-800 transition duration-150 ease-in-out p-2 rounded-full hover:bg-blue-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                </button>
                <button id="loadSettingsBtn" title="è¼‰å…¥ä¸Šæ¬¡è¨­å®š" class="hidden text-green-600 hover:text-green-800 transition duration-150 ease-in-out p-2 rounded-full hover:bg-green-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                </button>
            </div>
        </div>
    </header>

    <!-- ä¸»è¦å…§å®¹å€ -->
    <main class="content-container max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-12">
        
        <!-- æª”æ¡ˆä¸Šå‚³èˆ‡æ§åˆ¶å€ -->
        <div id="controls" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">æ­¥é©Ÿ 1: ä¸Šå‚³åœ–ç‰‡èˆ‡è¨­å®š</h2>
            
            <!-- A. åœ–ç‰‡ä¸Šå‚³ -->
            <label for="imageUpload" class="file-upload-label cursor-pointer flex items-center justify-center p-4 border-2 border-dashed border-blue-400 bg-blue-50/50 rounded-lg text-blue-700 font-medium mb-4">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                <span>ğŸ“‚ é»æ“Šæˆ–æ‹–æ›³åœ–ç‰‡åˆ°æ­¤è™•ä¸Šå‚³</span>
            </label>
            <input type="file" id="imageUpload" accept="image/*" class="hidden" aria-label="ä¸Šå‚³åœ–ç‰‡æª”æ¡ˆ">

            <!-- ä¸Šå‚³é€²åº¦é¡¯ç¤ºå€ -->
            <div id="upload-progress-container" class="mt-3 hidden">
                <p id="upload-status" class="text-sm text-gray-700 mb-1">æº–å‚™ä¸­...</p>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>

            <!-- B. åƒæ•¸è¨­å®š -->
            <div id="settings-area" class="mt-4 p-4 border rounded-lg bg-gray-50 hidden">
                
				<!-- å¿«é€Ÿç¯„æœ¬é¸æ“‡ -->
				<div class="mb-4 p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg border border-purple-200">
					<label class="block text-sm font-bold text-gray-800 mb-2">ğŸš€ å¿«é€Ÿç¯„æœ¬ï¼š</label>
					<div class="flex flex-wrap gap-2">
						<button onclick="CropTool.applyTemplate(1, 2)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">1Ã—2 ä¸Šä¸‹</button>
						<button onclick="CropTool.applyTemplate(2, 1)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">2Ã—1 å·¦å³</button>
						<button onclick="CropTool.applyTemplate(2, 2)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">2Ã—2 å››å®®æ ¼</button>
						<button onclick="CropTool.applyTemplate(3, 3)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">3Ã—3 ä¹å®®æ ¼</button>
						<button onclick="CropTool.applyTemplate(3, 4)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">3Ã—4 åäºŒå®®æ ¼</button>
						<button onclick="CropTool.applyTemplate(4, 3)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">4Ã—3 åäºŒå®®æ ¼</button>
						<button onclick="CropTool.applyTemplate(4, 4)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">4Ã—4 åå…­å®®æ ¼</button>
					</div>
				</div>



                <!-- å‰ªè£æ¨¡å¼åˆ‡æ› -->
                <label class="block text-sm font-medium text-gray-700 mb-2">å‰ªè£æ¨¡å¼:</label>
                <div class="flex space-x-4 mb-4">
                    <label class="flex items-center">
                        <input type="radio" name="cropMode" value="auto" checked id="modeAuto" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500" onclick="CropTool.switchMode('auto')">
                        <span class="ml-2 text-sm text-gray-700">è‡ªå‹•å„ªåŒ– (ç¸½å¼µæ•¸)</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="cropMode" value="custom" id="modeCustom" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500" onclick="CropTool.switchMode('custom')">
                        <span class="ml-2 text-sm text-gray-700">è‡ªè¨‚æ ¼ç·š (è¡Œåˆ—æ•¸)</span>
                    </label>
                </div>

                <!-- è‡ªå‹•æ¨¡å¼è¼¸å…¥ -->
                <div id="auto-mode-inputs">
                    <label for="cropCount" class="block text-sm font-medium text-gray-700 mb-1">
                        è¼¸å…¥æœŸæœ›çš„å‰ªè£çµæœç¸½å¼µæ•¸ (N)ï¼š
                    </label>
                    <input type="number" id="cropCount" value="9" min="1" max="100" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="ä¾‹å¦‚ï¼š4">
                </div>

                <!-- è‡ªè¨‚æ¨¡å¼è¼¸å…¥ -->
                <div id="custom-mode-inputs" class="hidden">
                    <div class="flex space-x-4">
                        <div class="flex-1">
                            <label for="rowsInput" class="block text-sm font-medium text-gray-700 mb-1">
                                åˆ—æ•¸ (é«˜ R)ï¼š
                            </label>
                            <input type="number" id="rowsInput" value="2" min="1" max="20" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div class="flex-1">
                            <label for="colsInput" class="block text-sm font-medium text-gray-700 mb-1">
                                è¡Œæ•¸ (å¯¬ C)ï¼š
                            </label>
                            <input type="number" id="colsInput" value="2" min="1" max="20" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    </div>
                </div>

                <!-- å»èƒŒé¸é … -->
                <div class="mt-4 p-4 bg-blue-50 rounded-lg border border-blue-100">
                    <label class="block text-sm font-bold text-gray-800 mb-2">
                        é€²éšåŠŸèƒ½ï¼šèƒŒæ™¯å»é™¤
                    </label>
                    
                    <div class="flex items-center space-x-2 mb-3">
                        <input type="checkbox" id="removeBackground" class="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <span class="text-sm font-medium text-gray-800">å•Ÿç”¨è‰²å½©å»èƒŒ (é©åˆç´”è‰²èƒŒæ™¯)</span>
                    </div>

                    <!-- é€²éšå»èƒŒæ§åˆ¶é … -->
                    <div id="bg-removal-controls" class="hidden pl-6 border-l-2 border-blue-200 space-y-3">
                        <div class="flex items-center space-x-3">
                            <label for="targetColor" class="text-sm text-gray-700">é¸æ“‡è¦å»é™¤çš„é¡è‰²ï¼š</label>
                            <input type="color" id="targetColor" value="#ffffff" class="h-8 w-14 cursor-pointer border rounded">
                        </div>
                        
                        <div>
                            <div class="flex justify-between">
                                <label for="tolerance" class="text-sm text-gray-700">å®¹è¨±åº¦ (Tolerance)ï¼š</label>
                                <span id="tolerance-value" class="text-sm font-medium text-blue-600">15%</span>
                            </div>
                            <input type="range" id="tolerance" min="0" max="100" value="15" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer mt-1">
                            <p class="text-xs text-gray-500 mt-1">æ•¸å€¼è¶Šé«˜ï¼Œå»é™¤çš„é¡è‰²ç¯„åœè¶Šå»£ (åŒ…å«é™°å½±æˆ–ç›¸è¿‘è‰²)ã€‚</p>
                        </div>
                    </div>
                </div>

                <p id="grid-info" class="text-sm text-gray-500 mt-2">ç›®å‰åŠƒåˆ†ç‚º 2 åˆ— x 2 è¡Œã€‚</p>
            </div>
            
            <div id="message-box" class="mt-4 p-3 rounded-lg text-sm text-center font-medium hidden"></div>

        </div>

        <!-- C. åœ–ç‰‡é è¦½èˆ‡ç·¨è¼¯å€ -->
        <div id="canvas-wrapper" class="hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-white">æ­¥é©Ÿ 2: èª¿æ•´å‰ªè£æ ¼ç·š (æ‹–æ›³æ ¼ç·š)</h2>
                <div class="flex space-x-2">
                    <button id="undoBtn" class="px-3 py-1.5 bg-white/90 hover:bg-white text-gray-700 font-medium rounded-lg shadow-sm transition flex items-center space-x-1" title="å¾©åŸä¸Šä¸€æ­¥ (Ctrl+Z)">
                        <span>â†¶</span>
                        <span class="hidden sm:inline">å¾©åŸ</span>
                    </button>
                    <button id="redoBtn" class="px-3 py-1.5 bg-white/90 hover:bg-white text-gray-700 font-medium rounded-lg shadow-sm transition flex items-center space-x-1" title="é‡åš (Ctrl+Y)">
                        <span>â†·</span>
                        <span class="hidden sm:inline">é‡åš</span>
                    </button>
                    <button id="resetBtn" class="px-3 py-1.5 bg-white/90 hover:bg-white text-gray-700 font-medium rounded-lg shadow-sm transition flex items-center space-x-1" title="é‡ç½®ç‚ºå‡åˆ†æ ¼ç·š">
                        <span>âŸ²</span>
                        <span class="hidden sm:inline">é‡ç½®</span>
                    </button>
                </div>
            </div>
            <div id="canvas-container">
                <canvas id="cropCanvas" tabindex="0" role="img" aria-label="å¯æ‹–æ›³èª¿æ•´çš„å‰ªè£æ ¼ç·šé è¦½"></canvas>
                <!-- æ‹–æ›³æ™‚çš„é è¦½ç•«é¢ -->
                <div id="drag-preview">
                    <canvas id="previewCanvas"></canvas>
                    <div id="preview-info" class="text-xs text-center mt-1 font-medium text-gray-700"></div>
                </div>
            </div>
        </div>

        <!-- D. åŸ·è¡Œèˆ‡ä¸‹è¼‰ -->
        <div id="action-area" class="mt-8 hidden">
            <h2 class="text-xl font-semibold text-white mb-4">æ­¥é©Ÿ 3: å®Œæˆå‰ªè£</h2>
            <button id="cropButton" class="w-full sm:w-auto px-8 py-3 text-lg font-semibold text-white rounded-xl shadow-lg transition duration-300 ease-in-out 
                bg-pink-500 hover:bg-pink-600 focus:outline-none focus:ring-4 focus:ring-pink-300" aria-describedby="crop-description">
                âœ‚ï¸ é–‹å§‹å‰ªè£
            </button>
            <div id="crop-description" class="sr-only">é»æ“Šæ­¤æŒ‰éˆ•å°‡æ ¹æ“šç•¶å‰æ ¼ç·šè¨­å®šå‰ªè£åœ–ç‰‡</div>
            
            <div id="download-area" class="mt-6 p-4 bg-white rounded-xl shadow-lg hidden">
                <h3 class="text-lg font-medium text-gray-700 mb-3">å‰ªè£çµæœé è¦½ï¼š</h3>
                
                <!-- ä¸€éµæ‰“åŒ…ä¸‹è¼‰æŒ‰éˆ• -->
                <a id="bulkDownloadLink" href="#" 
                   class="mb-4 px-4 py-2 bg-green-500 text-white font-semibold rounded-xl shadow-md hover:bg-green-600 transition duration-150 ease-in-out hidden text-center cursor-pointer inline-block" 
                   download="smart_crop_images.zip" title="ä¸‹è¼‰æ‰€æœ‰å‰ªè£å¾Œçš„åœ–ç‰‡">
                    â¬‡ï¸ ä¸‹è¼‰æ‰€æœ‰åœ–ç‰‡ (ZIP)
                </a>

                <!-- é è¦½ç¶²æ ¼ -->
                <div id="preview-grid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 mt-4">
                    <!-- å‰ªè£å¾Œçš„å°åœ–å°‡é¡¯ç¤ºåœ¨é€™è£¡ -->
                </div>
            </div>
        </div>

    </main>

    <!-- ç‰ˆæ¬Šå®£å‘Š -->
    <footer class="bg-white/90 py-4 mt-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center text-sm text-gray-600">
            Made with â¤ï¸ by Randy Â© 2025
        </div>
    </footer>

    <script>
        // =========================================================
        // é…ç½®å¸¸æ•¸
        // =========================================================
        const CONFIG = {
            // äº’å‹•è¨­å®š
            HIT_AREA: 15,              // æ ¼ç·šé»æ“Šå®¹éŒ¯ç¯„åœï¼ˆpxï¼‰
            LINE_MIN_POSITION: 0.05,   // æ ¼ç·šæœ€å°ä½ç½®ï¼ˆ5%ï¼‰
            LINE_MAX_POSITION: 0.95,   // æ ¼ç·šæœ€å¤§ä½ç½®ï¼ˆ95%ï¼‰
            
            // æª”æ¡ˆé™åˆ¶
            MAX_FILE_SIZE: 20 * 1024 * 1024,  // 20MB
            MAX_CROPS: 100,                    // æœ€å¤šå‰ªè£æ•¸é‡
            
            // å»èƒŒè¨­å®š
            DEFAULT_BG_COLOR: '#ffffff',
            DEFAULT_TOLERANCE: 15,
            
            // UI è¨­å®š
            PREVIEW_MAX_SIZE: 120,
            LINE_WIDTH: 2,
            DOT_SIZE: 8,
            
            // æ”¯æ´çš„æª”æ¡ˆæ ¼å¼
            VALID_FILE_TYPES: ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp'],
			
			// âœ¨ æ–°å¢ï¼šè‡ªå‹•åµæ¸¬è¨­å®š
			AUTO_DETECT: {
				DEFAULT_CROP_COUNT: 9,           // é è¨­ 9 å¼µ
				EDGE_THRESHOLD: 40,               // é‚Šç·£æª¢æ¸¬é–¾å€¼
				MIN_LINE_STRENGTH: 0.6,           // æœ€å°ç·šæ¢å¼·åº¦ï¼ˆ60%ï¼‰
				SAMPLE_DENSITY: 2                 // å–æ¨£å¯†åº¦ï¼ˆæ¯ N å€‹åƒç´ å–æ¨£ä¸€æ¬¡ï¼‰			
				}
		};

        // =========================================================
        // ä¸»è¦æ‡‰ç”¨ç¨‹å¼ç‰©ä»¶
        // =========================================================
        const CropTool = {
            // DOM å…ƒç´ 
            elements: {},
            
            // ç‹€æ…‹
            state: {
                image: null,
                imgRatio: 1, 
                lines: {
                    vertical: [], 
                    horizontal: [] 
                },
                draggingLine: null, 
                grid: { rows: 3, cols: 3 },
                cropCount: 9,
                removeBackground: false,
                bgTargetColor: CONFIG.DEFAULT_BG_COLOR,
                bgTolerance: CONFIG.DEFAULT_TOLERANCE,
                mode: 'auto',
				autoDetectResult: null
            },
            
            // æ­·å²è¨˜éŒ„
            history: {
                states: [],
                currentIndex: -1,
                
                push(lines) {
                    this.states = this.states.slice(0, this.currentIndex + 1);
                    this.states.push(JSON.parse(JSON.stringify(lines)));
                    this.currentIndex++;
                    CropTool.updateHistoryButtons();
                },
                
                undo() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--;
                        CropTool.updateHistoryButtons();
                        return this.states[this.currentIndex];
                    }
                    return null;
                },
                
                redo() {
                    if (this.currentIndex < this.states.length - 1) {
                        this.currentIndex++;
                        CropTool.updateHistoryButtons();
                        return this.states[this.currentIndex];
                    }
                    return null;
                },
                
                clear() {
                    this.states = [];
                    this.currentIndex = -1;
                    CropTool.updateHistoryButtons();
                }
            },
            
            // éŸ³æ•ˆ
            synth: null,
            
            // =========================================================
            // åˆå§‹åŒ–
            // =========================================================
            init() {
                this.cacheElements();
                this.bindEvents();
                this.initAudio();
                this.loadSettings();
            },
            
            cacheElements() {
                const $ = (id) => document.getElementById(id);
                
                this.elements = {
                    canvas: $('cropCanvas'),
                    imageUpload: $('imageUpload'),
                    cropCountInput: $('cropCount'),
                    gridInfo: $('grid-info'),
                    cropButton: $('cropButton'),
                    previewGrid: $('preview-grid'),
                    settingsArea: $('settings-area'),
                    canvasWrapper: $('canvas-wrapper'),
                    actionArea: $('action-area'),
                    messageBox: $('message-box'),
                    bulkDownloadLink: $('bulkDownloadLink'),
                    removeBackgroundCheckbox: $('removeBackground'),
                    bgRemovalControls: $('bg-removal-controls'),
                    targetColorInput: $('targetColor'),
                    toleranceInput: $('tolerance'),
                    toleranceValue: $('tolerance-value'),
                    rowsInput: $('rowsInput'),
                    colsInput: $('colsInput'),
                    autoModeInputs: $('auto-mode-inputs'),
                    customModeInputs: $('custom-mode-inputs'),
                    dragPreview: $('drag-preview'),
                    previewCanvas: $('previewCanvas'),
                    previewInfo: $('preview-info'),
                    uploadProgressContainer: $('upload-progress-container'),
                    uploadStatus: $('upload-status'),
                    progressBar: $('progress-bar'),
                    uploadLabel: document.querySelector('.file-upload-label'),
                    undoBtn: $('undoBtn'),
                    redoBtn: $('redoBtn'),
                    resetBtn: $('resetBtn'),
                    saveSettingsBtn: $('saveSettingsBtn'),
                    loadSettingsBtn: $('loadSettingsBtn'),
                    downloadArea: $('download-area')
                };
                
                this.elements.ctx = this.elements.canvas.getContext('2d');
                this.elements.previewCtx = this.elements.previewCanvas.getContext('2d');
            },
            
			bindEvents() {
			    // åœ–ç‰‡ä¸Šå‚³
			    this.elements.imageUpload.addEventListener('change', (e) => this.handleImageUpload(e));
			    
			    // æ‹–æ”¾ä¸Šå‚³
			    this.elements.uploadLabel.addEventListener('dragover', (e) => this.handleDragOver(e));
			    this.elements.uploadLabel.addEventListener('dragleave', () => this.handleDragLeave());
			    this.elements.uploadLabel.addEventListener('drop', (e) => this.handleDrop(e));
			    
			    // ========== åƒæ•¸è®Šæ›´ - cropCount (ç¸½å¼µæ•¸) ==========
			    // é»æ“Šæ™‚å…¨é¸
			    this.elements.cropCountInput.addEventListener('focus', (e) => {
			        e.target.select();
			    });
			    
			    // è¼¸å…¥æ™‚è™•ç†ï¼ˆå…è¨±æš«æ™‚ç‚ºç©ºï¼‰
			    this.elements.cropCountInput.addEventListener('input', (e) => {
			        if (e.target.value === '') return; // å…è¨±æš«æ™‚æ¸…ç©º
			        if (this.state.mode === 'auto') this.updateGrid();
			    });
			    
			    // å¤±ç„¦æ™‚æª¢æŸ¥æœ€å°å€¼
			    this.elements.cropCountInput.addEventListener('blur', (e) => {
			        if (e.target.value === '' || parseInt(e.target.value) < 1) {
			            e.target.value = 1;
			            if (this.state.mode === 'auto') this.updateGrid();
			        }
			    });
			    
			    // ========== åƒæ•¸è®Šæ›´ - rowsInput (åˆ—æ•¸) ==========
			    // é»æ“Šæ™‚å…¨é¸
			    this.elements.rowsInput.addEventListener('focus', (e) => {
			        e.target.select();
			    });
			    
			    // è¼¸å…¥æ™‚è™•ç†ï¼ˆå…è¨±æš«æ™‚ç‚ºç©ºï¼‰
			    this.elements.rowsInput.addEventListener('input', (e) => {
			        if (e.target.value === '') return; // å…è¨±æš«æ™‚æ¸…ç©º
			        this.updateGrid();
			    });
			    
			    // å¤±ç„¦æ™‚æª¢æŸ¥æœ€å°å€¼
			    this.elements.rowsInput.addEventListener('blur', (e) => {
			        if (e.target.value === '' || parseInt(e.target.value) < 1) {
			            e.target.value = 1;
			            this.updateGrid();
			        }
			    });
			    
			    // ========== åƒæ•¸è®Šæ›´ - colsInput (è¡Œæ•¸) ==========
			    // é»æ“Šæ™‚å…¨é¸
			    this.elements.colsInput.addEventListener('focus', (e) => {
			        e.target.select();
			    });
			    
			    // è¼¸å…¥æ™‚è™•ç†ï¼ˆå…è¨±æš«æ™‚ç‚ºç©ºï¼‰
			    this.elements.colsInput.addEventListener('input', (e) => {
			        if (e.target.value === '') return; // å…è¨±æš«æ™‚æ¸…ç©º
			        this.updateGrid();
			    });
			    
			    // å¤±ç„¦æ™‚æª¢æŸ¥æœ€å°å€¼
			    this.elements.colsInput.addEventListener('blur', (e) => {
			        if (e.target.value === '' || parseInt(e.target.value) < 1) {
			            e.target.value = 1;
			            this.updateGrid();
			        }
			    });
			    
			    // å»èƒŒé¸é …
			    this.elements.removeBackgroundCheckbox.addEventListener('change', () => this.toggleBackgroundRemoval());
			    this.elements.targetColorInput.addEventListener('input', (e) => {
			        this.state.bgTargetColor = e.target.value;
			    });
			    this.elements.toleranceInput.addEventListener('input', (e) => {
			        this.state.bgTolerance = parseInt(e.target.value);
			        this.elements.toleranceValue.textContent = `${this.state.bgTolerance}%`;
			    });
			    
			    // Canvas äº’å‹•
			    this.elements.canvas.addEventListener('mousedown', (e) => this.handleStart(e.clientX, e.clientY));
			    document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
			    document.addEventListener('mouseup', () => this.handleEnd());
			    
			    this.elements.canvas.addEventListener('touchstart', (e) => {
			        e.preventDefault();
			        const touch = e.touches[0];
			        this.handleStart(touch.clientX, touch.clientY);
			    });
			    this.elements.canvas.addEventListener('touchmove', (e) => {
			        if (this.state.draggingLine) {
			            const touch = e.touches[0];
			            this.handleMove(touch.clientX, touch.clientY);
			        }
			    });
			    this.elements.canvas.addEventListener('touchend', () => this.handleEnd());
			    
			    // å‰ªè£æŒ‰éˆ•
			    this.elements.cropButton.addEventListener('click', () => this.executeCrop());
			    
			    // æ­·å²è¨˜éŒ„æŒ‰éˆ•
			    this.elements.undoBtn.addEventListener('click', () => this.undo());
			    this.elements.redoBtn.addEventListener('click', () => this.redo());
			    this.elements.resetBtn.addEventListener('click', () => this.resetGrid());
			    
			    // è¨­å®šå„²å­˜/è¼‰å…¥
			    this.elements.saveSettingsBtn.addEventListener('click', () => this.saveSettings());
			    this.elements.loadSettingsBtn.addEventListener('click', () => this.loadSettings());
			    
			    // éµç›¤å¿«æ·éµ
			    document.addEventListener('keydown', (e) => this.handleKeyboard(e));
			    
			    // è¦–çª—å¤§å°èª¿æ•´
			    window.addEventListener('resize', () => this.handleResize());
			},

            
            initAudio() {
                document.addEventListener('click', () => {
                    if (!this.synth) {
                        try {
                            this.synth = new Tone.Synth().toDestination();
                        } catch (error) {
                            console.error("Tone.js åˆå§‹åŒ–å¤±æ•—:", error);
                        }
                    }
                }, { once: true });
            },
            
            // =========================================================
            // éŸ³æ•ˆæ’­æ”¾
            // =========================================================
            playSound(note, duration = '8n', time = '+0.05') {
                if (this.synth) {
                    try {
                        this.synth.triggerAttackRelease(note, duration, time);
                    } catch (e) {
                        console.warn("æ’­æ”¾éŸ³æ•ˆå¤±æ•—:", e);
                    }
                }
            },
            
            // =========================================================
            // åœ–ç‰‡ä¸Šå‚³è™•ç†
            // =========================================================
            handleImageUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // æª”æ¡ˆå¤§å°æª¢æŸ¥
                if (file.size > CONFIG.MAX_FILE_SIZE) {
                    this.showMessage(`æª”æ¡ˆéå¤§ï¼è«‹ä¸Šå‚³å°æ–¼ ${CONFIG.MAX_FILE_SIZE / 1024 / 1024}MB çš„åœ–ç‰‡ã€‚`, 'bg-red-100 text-red-700');
                    return;
                }
                
                // æª”æ¡ˆé¡å‹æª¢æŸ¥
                if (!CONFIG.VALID_FILE_TYPES.includes(file.type)) {
                    this.showMessage('ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ï¼è«‹ä¸Šå‚³ JPGã€PNGã€WebPã€GIF æˆ– BMPã€‚', 'bg-red-100 text-red-700');
                    return;
                }
                
                this.loadImage(file);
            },
            
            loadImage(file) {
                this.elements.uploadProgressContainer.classList.remove('hidden');
                this.elements.uploadStatus.textContent = 'æº–å‚™ä¸­...';
                this.elements.progressBar.style.width = '10%';
                
                this.elements.settingsArea.classList.remove('hidden');
                this.elements.canvasWrapper.classList.remove('hidden');
                this.elements.actionArea.classList.remove('hidden');
                this.elements.previewGrid.innerHTML = '';
                this.elements.downloadArea.classList.add('hidden');
                this.elements.bulkDownloadLink.classList.add('hidden');
                
                const reader = new FileReader();
                
                reader.onloadstart = () => {
                    this.elements.uploadStatus.textContent = 'æª”æ¡ˆè®€å–ä¸­...';
                    this.elements.progressBar.style.width = '30%';
                };
                
                reader.onprogress = (event) => {
                    if (event.lengthComputable) {
                        const percent = (event.loaded / event.total) * 100;
                        this.elements.uploadStatus.textContent = `æª”æ¡ˆè®€å–ä¸­: ${percent.toFixed(0)}%`;
                        this.elements.progressBar.style.width = `${Math.min(percent, 80)}%`;
                    }
                };
                
                reader.onload = (event) => {
                    const img = new Image();
					img.onload = () => {
						this.state.image = img;
						this.state.imgRatio = img.width / img.height;
						
						setTimeout(() => {
							this.elements.uploadStatus.textContent = 'åœ–ç‰‡è§£ç¢¼å®Œæˆï¼Œæ­£åœ¨åˆ†æä¸­...';
							this.elements.progressBar.style.width = '85%';
							
							// âœ… åŸ·è¡Œè‡ªå‹•åµæ¸¬
							const detected = this.autoDetectGrid();
							this.state.autoDetectResult = detected;
							
							// âœ… å¥—ç”¨åµæ¸¬çµæœ
							if (detected) {
								this.applyDetectionResult(detected);
							}
							
							const containerWidth = document.getElementById('canvas-container').clientWidth || 600;
							const canvasWidth = containerWidth;
							const canvasHeight = canvasWidth / this.state.imgRatio;
							
							this.elements.canvas.width = img.width;
							this.elements.canvas.height = img.height;
							this.elements.canvas.style.width = `${canvasWidth}px`;
							this.elements.canvas.style.height = `${canvasHeight}px`;
							
							this.history.clear();
							this.updateGrid();
							this.playSound('A4');
							
							// âœ… é¡¯ç¤ºåµæ¸¬çµæœè¨Šæ¯
							this.showDetectionMessage(detected);
							
							this.elements.uploadStatus.textContent = 'å®Œæˆï¼';
							this.elements.progressBar.style.width = '100%';
							setTimeout(() => {
								this.elements.uploadProgressContainer.classList.add('hidden');
								this.elements.progressBar.style.width = '0%';
							}, 500);
						}, 0);
					};


                    
                    img.onerror = () => {
                        this.showMessage("åœ–ç‰‡è§£ç¢¼å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºã€‚", 'bg-red-100 text-red-700');
                        this.elements.uploadProgressContainer.classList.add('hidden');
                    };
                    
                    img.src = event.target.result;
                };
                
                reader.onerror = () => {
                    this.showMessage("æª”æ¡ˆè®€å–å¤±æ•—ï¼", 'bg-red-100 text-red-700');
                    this.elements.uploadProgressContainer.classList.add('hidden');
                };
                
                reader.readAsDataURL(file);
            },
            
            // =========================================================
            // æ‹–æ”¾è™•ç†
            // =========================================================
            handleDragOver(e) {
                e.preventDefault();
                this.elements.uploadLabel.classList.add('border-green-600', 'bg-green-50/50');
            },
            
            handleDragLeave() {
                this.elements.uploadLabel.classList.remove('border-green-600', 'bg-green-50/50');
            },
            
            handleDrop(e) {
                e.preventDefault();
                this.elements.uploadLabel.classList.remove('border-green-600', 'bg-green-50/50');
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    this.elements.imageUpload.files = e.dataTransfer.files;
                    this.handleImageUpload({ target: this.elements.imageUpload });
                }
            },
            
            // =========================================================
            // æ ¼ç·šè¨ˆç®—èˆ‡æ›´æ–°
            // =========================================================
            calculateOptimalGrid(N) {
                if (N <= 0) return { rows: 1, cols: 1 };
                
                let bestR = 1;
                let bestC = N;
                let minDiff = N;
                
                for (let r = 1; r * r <= N; r++) {
                    if (N % r === 0) {
                        const c = N / r;
                        if (Math.abs(r - c) < minDiff) {
                            minDiff = Math.abs(r - c);
                            bestR = r;
                            bestC = c;
                        }
                    }
                }
                
                if (minDiff === N) {
                    for (let r = 1; r <= N; r++) {
                        const c = Math.ceil(N / r);
                        const diff = Math.abs(r - c);
                        if (diff < minDiff || (diff === minDiff && r * c >= N && r * c < bestR * bestC)) {
                            minDiff = diff;
                            bestR = r;
                            bestC = c;
                        }
                    }
                }
                
                if (this.state.imgRatio > 1 && bestR > bestC) {
                    return { rows: bestC, cols: bestR };
                } else if (this.state.imgRatio < 1 && bestC > bestR) {
                    return { rows: bestC, cols: bestR };
                }
                
                return { rows: bestR, cols: bestC };
            },

			// =========================================================
			// è‡ªå‹•åµæ¸¬æ ¼ç·š
			// =========================================================
			autoDetectGrid() {
				if (!this.state.image) return null;
				
				const img = this.state.image;
				const ratio = img.width / img.height;
				
				// å»ºç«‹è‡¨æ™‚ canvas é€²è¡Œåˆ†æ
				const tempCanvas = document.createElement('canvas');
				const tempCtx = tempCanvas.getContext('2d');
				
				// ç¸®å°åœ–ç‰‡ä»¥åŠ å¿«åˆ†æé€Ÿåº¦
				const maxAnalysisSize = 800;
				let analysisWidth = img.width;
				let analysisHeight = img.height;
				
				if (img.width > maxAnalysisSize || img.height > maxAnalysisSize) {
					if (img.width > img.height) {
						analysisWidth = maxAnalysisSize;
						analysisHeight = Math.round(maxAnalysisSize / ratio);
					} else {
						analysisHeight = maxAnalysisSize;
						analysisWidth = Math.round(maxAnalysisSize * ratio);
					}
				}
				
				tempCanvas.width = analysisWidth;
				tempCanvas.height = analysisHeight;
				tempCtx.drawImage(img, 0, 0, analysisWidth, analysisHeight);
				
				// æ–¹æ³• 1: é‚Šç·£æª¢æ¸¬
				const detectedLines = this.detectSeparatorLines(tempCanvas, tempCtx);
				
				// æ–¹æ³• 3: é•·å¯¬æ¯”åˆ†æ
				const ratioSuggestion = this.analyzeAspectRatio(ratio);
				
				// ç¶œåˆåˆ¤æ–·
				let result = {
					method: '',
					rows: 3,
					cols: 3,
					confidence: 0,
					lines: { vertical: [], horizontal: [] }
				};
				
				// å¦‚æœåµæ¸¬åˆ°æ˜é¡¯çš„åˆ†éš”ç·š
				if (detectedLines.confidence > 0.5) {
					result = {
						method: 'edge-detection',
						rows: detectedLines.horizontal.length + 1,
						cols: detectedLines.vertical.length + 1,
						confidence: detectedLines.confidence,
						lines: {
							vertical: detectedLines.vertical,
							horizontal: detectedLines.horizontal
						}
					};
				} 
				// å¦‚æœé•·å¯¬æ¯”æ¥µç«¯
				else if (ratioSuggestion.confidence > 0.7) {
					result = {
						method: 'aspect-ratio',
						rows: ratioSuggestion.rows,
						cols: ratioSuggestion.cols,
						confidence: ratioSuggestion.confidence,
						lines: { vertical: [], horizontal: [] }
					};
				}
				// ä½¿ç”¨é è¨­å€¼
				else {
					const optimal = this.calculateOptimalGrid(CONFIG.AUTO_DETECT.DEFAULT_CROP_COUNT);
					result = {
						method: 'default',
						rows: optimal.rows,
						cols: optimal.cols,
						confidence: 0.3,
						lines: { vertical: [], horizontal: [] }
					};
				}
				
				return result;
			},

			// åµæ¸¬åˆ†éš”ç·š
			detectSeparatorLines(canvas, ctx) {
				const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
				const data = imageData.data;
				const width = canvas.width;
				const height = canvas.height;
				
				const threshold = CONFIG.AUTO_DETECT.EDGE_THRESHOLD;
				const density = CONFIG.AUTO_DETECT.SAMPLE_DENSITY;
				
				// è¨ˆç®—æ¯ä¸€åˆ—çš„é‚Šç·£å¼·åº¦ï¼ˆæª¢æ¸¬æ°´å¹³ç·šï¼‰
				const horizontalStrength = [];
				for (let y = 0; y < height; y += density) {
					let edgeCount = 0;
					let totalSamples = 0;
					
					for (let x = 1; x < width - 1; x += density) {
						const idx = (y * width + x) * 4;
						const prevIdx = (y * width + (x - 1)) * 4;
						
						// è¨ˆç®—ç°éšå€¼
						const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
						const prevGray = (data[prevIdx] + data[prevIdx + 1] + data[prevIdx + 2]) / 3;
						
						// æª¢æ¸¬é‚Šç·£
						if (Math.abs(gray - prevGray) > threshold) {
							edgeCount++;
						}
						totalSamples++;
					}
					
					horizontalStrength.push(edgeCount / totalSamples);
				}
				
				// è¨ˆç®—æ¯ä¸€è¡Œçš„é‚Šç·£å¼·åº¦ï¼ˆæª¢æ¸¬å‚ç›´ç·šï¼‰
				const verticalStrength = [];
				for (let x = 0; x < width; x += density) {
					let edgeCount = 0;
					let totalSamples = 0;
					
					for (let y = 1; y < height - 1; y += density) {
						const idx = (y * width + x) * 4;
						const prevIdx = ((y - 1) * width + x) * 4;
						
						const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
						const prevGray = (data[prevIdx] + data[prevIdx + 1] + data[prevIdx + 2]) / 3;
						
						if (Math.abs(gray - prevGray) > threshold) {
							edgeCount++;
						}
						totalSamples++;
					}
					
					verticalStrength.push(edgeCount / totalSamples);
				}
				
				// æ‰¾å‡ºå¼·åº¦å³°å€¼ï¼ˆå¯èƒ½çš„åˆ†éš”ç·šï¼‰
				const minStrength = CONFIG.AUTO_DETECT.MIN_LINE_STRENGTH;
				const horizontalLines = this.findPeaks(horizontalStrength, minStrength, density)
					.map(y => y / height);
				const verticalLines = this.findPeaks(verticalStrength, minStrength, density)
					.map(x => x / width);
				
				// è¨ˆç®—ä¿¡å¿ƒåº¦
				const avgHStrength = horizontalStrength.reduce((a, b) => a + b, 0) / horizontalStrength.length;
				const avgVStrength = verticalStrength.reduce((a, b) => a + b, 0) / verticalStrength.length;
				const confidence = Math.min(1, (avgHStrength + avgVStrength) / 2 + 0.3);
				
				return {
					horizontal: horizontalLines,
					vertical: verticalLines,
					confidence: horizontalLines.length > 0 || verticalLines.length > 0 ? confidence : 0
				};
			},

			// æ‰¾å‡ºå³°å€¼
			findPeaks(data, minStrength, density) {
				const peaks = [];
				const windowSize = Math.floor(20 / density); // 20px çª—å£
				
				for (let i = windowSize; i < data.length - windowSize; i++) {
					if (data[i] < minStrength) continue;
					
					let isPeak = true;
					for (let j = i - windowSize; j <= i + windowSize; j++) {
						if (j !== i && data[j] >= data[i]) {
							isPeak = false;
							break;
						}
					}
					
					if (isPeak) {
						peaks.push(i * density);
						i += windowSize; // è·³éé™„è¿‘å€åŸŸ
					}
				}
				
				return peaks;
			},

			// é•·å¯¬æ¯”åˆ†æ
			analyzeAspectRatio(ratio) {
				let rows = 3, cols = 3, confidence = 0.3;
				
				if (ratio > 3) {
					// æ¥µå¯¬åœ–ç‰‡ï¼ˆå¦‚å…¨æ™¯åœ–ï¼‰
					cols = Math.min(Math.ceil(ratio), 6);
					rows = 1;
					confidence = Math.min(0.9, 0.5 + ratio / 10);
				} else if (ratio > 2) {
					// å¯¬åœ–ç‰‡
					cols = 3;
					rows = 1;
					confidence = 0.7;
				} else if (ratio < 0.33) {
					// æ¥µé•·åœ–ç‰‡ï¼ˆå¦‚é•·æ¢æ¼«ç•«ï¼‰
					rows = Math.min(Math.ceil(1 / ratio), 6);
					cols = 1;
					confidence = Math.min(0.9, 0.5 + (1/ratio) / 10);
				} else if (ratio < 0.5) {
					// é•·åœ–ç‰‡
					rows = 3;
					cols = 1;
					confidence = 0.7;
				} else {
					// æ¥è¿‘æ­£æ–¹å½¢ï¼Œä½¿ç”¨é è¨­
					const optimal = this.calculateOptimalGrid(CONFIG.AUTO_DETECT.DEFAULT_CROP_COUNT);
					rows = optimal.rows;
					cols = optimal.cols;
					confidence = 0.5;
				}
				
				return { rows, cols, confidence };
			},

			applyDetectionResult(detected) {
				if (!detected) return;
				
				// åˆ‡æ›åˆ°è‡ªè¨‚æ¨¡å¼
				if (detected.rows !== 0 && detected.cols !== 0) {
					document.getElementById('modeCustom').checked = true;
					this.switchMode('custom');
					this.elements.rowsInput.value = detected.rows;
					this.elements.colsInput.value = detected.cols;
					this.state.grid.rows = detected.rows;
					this.state.grid.cols = detected.cols;
				}
				
				// å¦‚æœæœ‰åµæ¸¬åˆ°ç²¾ç¢ºçš„æ ¼ç·šä½ç½®ï¼Œç›´æ¥å¥—ç”¨
				if (detected.lines.vertical.length > 0 || detected.lines.horizontal.length > 0) {
					this.state.lines.vertical = [...detected.lines.vertical];
					this.state.lines.horizontal = [...detected.lines.horizontal];
				}
			},

			showDetectionMessage(detected) {
				if (!detected) return;
				
				const methodName = {
					'edge-detection': 'é‚Šç·£åµæ¸¬',
					'aspect-ratio': 'é•·å¯¬æ¯”åˆ†æ',
					'default': 'æ™ºæ…§å„ªåŒ–'
				};
				
				const confidencePercent = Math.round(detected.confidence * 100);
				const emoji = detected.confidence > 0.7 ? 'âœ¨' : detected.confidence > 0.5 ? 'ğŸ’¡' : 'ğŸ¤–';
				
				const message = `${emoji} è‡ªå‹•åµæ¸¬ï¼šå»ºè­°ä½¿ç”¨ ${detected.rows}Ã—${detected.cols} åˆ†å‰² (${methodName[detected.method]}ï¼Œä¿¡å¿ƒåº¦ ${confidencePercent}%)`;
				
				const className = detected.confidence > 0.7 
					? 'bg-green-100 text-green-700' 
					: 'bg-blue-100 text-blue-700';
				
				this.showMessage(message, className);
			},


            
            updateGrid() {
                if (!this.state.image) return;
                
                let rows, cols;
                
                if (this.state.mode === 'custom') {
                    rows = parseInt(this.elements.rowsInput.value) || 1;
                    cols = parseInt(this.elements.colsInput.value) || 1;
                    rows = Math.max(1, Math.min(rows, 20));
                    cols = Math.max(1, Math.min(cols, 20));
                    this.elements.rowsInput.value = rows;
                    this.elements.colsInput.value = cols;
                } else {
                    const N = parseInt(this.elements.cropCountInput.value) || 1;
                    this.state.cropCount = Math.max(1, Math.min(N, CONFIG.MAX_CROPS));
                    this.elements.cropCountInput.value = this.state.cropCount;
                    
                    const grid = this.calculateOptimalGrid(this.state.cropCount);
                    rows = grid.rows;
                    cols = grid.cols;
                }
                
                // æª¢æŸ¥ç¸½æ•¸é™åˆ¶
                if (rows * cols > CONFIG.MAX_CROPS) {
                    this.showMessage(`å‰ªè£æ•¸é‡éå¤šï¼æœ€å¤šæ”¯æ´ ${CONFIG.MAX_CROPS} å¼µã€‚`, 'bg-yellow-100 text-yellow-700');
                    rows = Math.min(rows, 10);
                    cols = Math.min(cols, 10);
                }
                
                this.state.grid.rows = rows;
                this.state.grid.cols = cols;
                
                this.elements.gridInfo.textContent = `ç›®å‰åŠƒåˆ†ç‚º ${rows} åˆ— x ${cols} è¡Œ (å…± ${rows * cols} å¡Š)ã€‚`;
                
                // é‡æ–°åˆå§‹åŒ–æ ¼ç·šï¼ˆå‡åˆ†ï¼‰
                this.state.lines.vertical = [];
                for (let i = 1; i < cols; i++) {
                    this.state.lines.vertical.push(i / cols);
                }
                
                this.state.lines.horizontal = [];
                for (let i = 1; i < rows; i++) {
                    this.state.lines.horizontal.push(i / rows);
                }
                
                this.history.clear();
                this.history.push(this.state.lines);
                this.drawCanvas();
            },
            
            // =========================================================
            // Canvas ç¹ªè£½
            // =========================================================
            drawCanvas() {
                if (!this.state.image) return;
                
                const width = this.elements.canvas.width;
                const height = this.elements.canvas.height;
                
                this.elements.ctx.clearRect(0, 0, width, height);
                this.elements.ctx.drawImage(this.state.image, 0, 0, width, height);
                
                this.elements.ctx.beginPath();
                this.elements.ctx.strokeStyle = this.state.draggingLine ? '#ff0000' : '#FFD700';
                this.elements.ctx.lineWidth = CONFIG.LINE_WIDTH;
                
                this.state.lines.vertical.forEach(normalizedX => {
                    const x = normalizedX * width;
                    this.elements.ctx.moveTo(x, 0);
                    this.elements.ctx.lineTo(x, height);
                });
                
                this.state.lines.horizontal.forEach(normalizedY => {
                    const y = normalizedY * height;
                    this.elements.ctx.moveTo(0, y);
                    this.elements.ctx.lineTo(width, y);
                });
                
                this.elements.ctx.stroke();
                
                // ç¹ªè£½æ‹–æ›³é»
                this.elements.ctx.fillStyle = '#4A90E2';
                const dotSize = CONFIG.DOT_SIZE;
                
                this.state.lines.vertical.forEach(normalizedX => {
                    const x = normalizedX * width;
                    this.elements.ctx.fillRect(x - dotSize / 2, height / 2 - dotSize / 2, dotSize, dotSize);
                });
                
                this.state.lines.horizontal.forEach(normalizedY => {
                    const y = normalizedY * height;
                    this.elements.ctx.fillRect(width / 2 - dotSize / 2, y - dotSize / 2, dotSize, dotSize);
                });
            },
            
            // =========================================================
            // äº’å‹•è™•ç†
            // =========================================================
            getLineUnderCursor(clientX, clientY) {
                const rect = this.elements.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                for (let i = 0; i < this.state.lines.vertical.length; i++) {
                    const lineX = this.state.lines.vertical[i] * rect.width;
                    if (Math.abs(x - lineX) < CONFIG.HIT_AREA) {
                        if (this.state.image && x >= 0 && x <= rect.width) {
                            return { type: 'vertical', index: i };
                        }
                    }
                }
                
                for (let i = 0; i < this.state.lines.horizontal.length; i++) {
                    const lineY = this.state.lines.horizontal[i] * rect.height;
                    if (Math.abs(y - lineY) < CONFIG.HIT_AREA) {
                        if (this.state.image && y >= 0 && y <= rect.height) {
                            return { type: 'horizontal', index: i };
                        }
                    }
                }
                
                return null;
            },
            
            handleStart(clientX, clientY) {
                const targetLine = this.getLineUnderCursor(clientX, clientY);
                if (targetLine) {
                    this.state.draggingLine = targetLine;
                    this.elements.canvas.style.cursor = targetLine.type === 'vertical' ? 'col-resize' : 'row-resize';
                    this.drawCanvas();
                    this.elements.dragPreview.style.display = 'block';
                } else {
                    this.state.draggingLine = null;
                    this.elements.canvas.style.cursor = 'default';
                    this.elements.dragPreview.style.display = 'none';
                }
            },
            
            handleMouseMove(e) {
                if (this.state.draggingLine) {
                    this.handleMove(e.clientX, e.clientY);
                } else if (this.state.image) {
                    const targetLine = this.getLineUnderCursor(e.clientX, e.clientY);
                    if (targetLine) {
                        this.elements.canvas.style.cursor = targetLine.type === 'vertical' ? 'col-resize' : 'row-resize';
                    } else {
                        this.elements.canvas.style.cursor = 'default';
                    }
                }
            },
            
            handleMove(clientX, clientY) {
                if (!this.state.draggingLine || !this.state.image) return;
                
                const rect = this.elements.canvas.getBoundingClientRect();
                let newValue;
                
                if (this.state.draggingLine.type === 'vertical') {
                    const x = clientX - rect.left;
                    newValue = Math.min(CONFIG.LINE_MAX_POSITION, Math.max(CONFIG.LINE_MIN_POSITION, x / rect.width));
                    this.state.lines.vertical[this.state.draggingLine.index] = newValue;
                } else {
                    const y = clientY - rect.top;
                    newValue = Math.min(CONFIG.LINE_MAX_POSITION, Math.max(CONFIG.LINE_MIN_POSITION, y / rect.height));
                    this.state.lines.horizontal[this.state.draggingLine.index] = newValue;
                }
                
                this.state.lines.vertical.sort((a, b) => a - b);
                this.state.lines.horizontal.sort((a, b) => a - b);
                
                this.drawCanvas();
                this.drawPreview(clientX, clientY);
            },
            
            handleEnd() {
                if (this.state.draggingLine) {
                    this.history.push(this.state.lines);
                }
                this.state.draggingLine = null;
                this.elements.canvas.style.cursor = 'default';
                this.elements.dragPreview.style.display = 'none';
                this.drawCanvas();
            },
            
            drawPreview(clientX, clientY) {
                if (!this.state.draggingLine || !this.state.image) return;
                
                const lineType = this.state.draggingLine.type;
                const lineIndex = this.state.draggingLine.index;
                
                const allLinesX = [0, ...this.state.lines.vertical, 1].sort((a, b) => a - b);
                const allLinesY = [0, ...this.state.lines.horizontal, 1].sort((a, b) => a - b);
                
                let normalizedStartX, normalizedEndX, normalizedStartY, normalizedEndY;
                let currentWidth, currentHeight;
                
                if (lineType === 'vertical') {
                    normalizedStartX = allLinesX[lineIndex];
                    normalizedEndX = allLinesX[lineIndex + 1];
                    normalizedStartY = allLinesY[0];
                    normalizedEndY = allLinesY[1] || 1;
                    
                    currentWidth = (normalizedEndX - normalizedStartX) * this.state.image.width;
                    currentHeight = (normalizedEndY - normalizedStartY) * this.state.image.height;
                } else {
                    normalizedStartX = allLinesX[0];
                    normalizedEndX = allLinesX[1] || 1;
                    normalizedStartY = allLinesY[lineIndex];
                    normalizedEndY = allLinesY[lineIndex + 1];
                    
                    currentWidth = (normalizedEndX - normalizedStartX) * this.state.image.width;
                    currentHeight = (normalizedEndY - normalizedStartY) * this.state.image.height;
                }
                
                const cropX = normalizedStartX * this.state.image.width;
                const cropY = normalizedStartY * this.state.image.height;
                const cropW = (normalizedEndX - normalizedStartX) * this.state.image.width;
                const cropH = (normalizedEndY - normalizedStartY) * this.state.image.height;
                
                this.elements.previewCanvas.width = cropW;
                this.elements.previewCanvas.height = cropH;
                
                this.elements.previewCtx.clearRect(0, 0, cropW, cropH);
                this.elements.previewCtx.drawImage(
                    this.state.image,
                    cropX, cropY, cropW, cropH,
                    0, 0, cropW, cropH
                );
                
                // æ›´æ–°é è¦½æ¡†ä½ç½®ï¼ˆé˜²æ­¢è¶…å‡ºè¦–çª—ï¼‰
                this.updatePreviewPosition(clientX, clientY);
                
                this.elements.previewInfo.textContent = `W: ${currentWidth.toFixed(0)}px / H: ${currentHeight.toFixed(0)}px`;
                
                const maxSize = CONFIG.PREVIEW_MAX_SIZE;
                if (cropW > cropH) {
                    this.elements.previewCanvas.style.width = `${maxSize}px`;
                    this.elements.previewCanvas.style.height = `${(cropH / cropW) * maxSize}px`;
                } else {
                    this.elements.previewCanvas.style.height = `${maxSize}px`;
                    this.elements.previewCanvas.style.width = `${(cropW / cropH) * maxSize}px`;
                }
            },
            
            updatePreviewPosition(clientX, clientY) {
                const previewRect = this.elements.dragPreview.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                let left = clientX + 20;
                let top = clientY + 20;
                
                if (left + previewRect.width > viewportWidth) {
                    left = clientX - previewRect.width - 20;
                }
                
                if (top + previewRect.height > viewportHeight) {
                    top = clientY - previewRect.height - 20;
                }
                
                this.elements.dragPreview.style.left = `${left + window.scrollX}px`;
                this.elements.dragPreview.style.top = `${top + window.scrollY}px`;
            },
            
            // =========================================================
            // æ­·å²è¨˜éŒ„åŠŸèƒ½
            // =========================================================
            undo() {
                const previousState = this.history.undo();
                if (previousState) {
                    this.state.lines = JSON.parse(JSON.stringify(previousState));
                    this.drawCanvas();
                    this.playSound('F4', '16n');
                }
            },
            
            redo() {
                const nextState = this.history.redo();
                if (nextState) {
                    this.state.lines = JSON.parse(JSON.stringify(nextState));
                    this.drawCanvas();
                    this.playSound('A4', '16n');
                }
            },
            
            resetGrid() {
                if (!this.state.image) return;
                this.updateGrid();
                this.playSound('C4', '16n');
                this.showMessage('å·²é‡ç½®ç‚ºå‡åˆ†æ ¼ç·š', 'bg-blue-100 text-blue-700');
            },
            
            updateHistoryButtons() {
                this.elements.undoBtn.disabled = this.history.currentIndex <= 0;
                this.elements.redoBtn.disabled = this.history.currentIndex >= this.history.states.length - 1;
                
                if (this.elements.undoBtn.disabled) {
                    this.elements.undoBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    this.elements.undoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                
                if (this.elements.redoBtn.disabled) {
                    this.elements.redoBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    this.elements.redoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            },
            
            // =========================================================
            // æ¨¡å¼åˆ‡æ›èˆ‡ç¯„æœ¬
            // =========================================================
            switchMode(mode) {
                this.state.mode = mode;
                if (mode === 'custom') {
                    this.elements.autoModeInputs.classList.add('hidden');
                    this.elements.customModeInputs.classList.remove('hidden');
                } else {
                    this.elements.customModeInputs.classList.add('hidden');
                    this.elements.autoModeInputs.classList.remove('hidden');
                }
                this.updateGrid();
            },
            
            applyTemplate(rows, cols) {
                document.getElementById('modeCustom').checked = true;
                this.switchMode('custom');
                this.elements.rowsInput.value = rows;
                this.elements.colsInput.value = cols;
                this.updateGrid();
                this.playSound('E5', '16n');
            },
            
            // =========================================================
            // å»èƒŒåŠŸèƒ½
            // =========================================================
            toggleBackgroundRemoval() {
                this.state.removeBackground = this.elements.removeBackgroundCheckbox.checked;
                if (this.state.removeBackground) {
                    this.elements.bgRemovalControls.classList.remove('hidden');
                } else {
                    this.elements.bgRemovalControls.classList.add('hidden');
                }
            },
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },
            
            // =========================================================
            // å‰ªè£åŸ·è¡Œ
            // =========================================================
            async executeCrop() {
                if (!this.state.image) {
                    this.showMessage("è«‹å…ˆä¸Šå‚³åœ–ç‰‡ï¼", 'bg-red-100 text-red-700');
                    return;
                }
                
                if (typeof JSZip === 'undefined') {
                    this.showMessage("JSZip å‡½å¼åº«æœªè¼‰å…¥ï¼Œç„¡æ³•åŸ·è¡Œæ‰“åŒ…ä¸‹è¼‰ã€‚", 'bg-red-100 text-red-700');
                    return;
                }
                
                this.playSound('C6');
                this.elements.cropButton.disabled = true;
                this.elements.bulkDownloadLink.classList.add('hidden');
                this.elements.cropButton.textContent = 'è™•ç†ä¸­... (æ­£åœ¨å‰ªè£)';
                this.elements.previewGrid.innerHTML = '';
                this.elements.downloadArea.classList.remove('hidden');
                
                const allLinesX = [0, ...this.state.lines.vertical, 1].sort((a, b) => a - b);
                const allLinesY = [0, ...this.state.lines.horizontal, 1].sort((a, b) => a - b);
                
                const originalWidth = this.state.image.width;
                const originalHeight = this.state.image.height;
                const croppedImages = [];
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                let targetRgb = null;
                let toleranceSq = 0;
                if (this.state.removeBackground) {
                    targetRgb = this.hexToRgb(this.state.bgTargetColor);
                    const tol = this.state.bgTolerance * 2.55;
                    toleranceSq = tol * tol * 3;
                }
                
                for (let r = 0; r < allLinesY.length - 1; r++) {
                    for (let c = 0; c < allLinesX.length - 1; c++) {
                        const normalizedStartX = allLinesX[c];
                        const normalizedEndX = allLinesX[c + 1];
                        const normalizedStartY = allLinesY[r];
                        const normalizedEndY = allLinesY[r + 1];
                        
                        const cropX = normalizedStartX * originalWidth;
                        const cropY = normalizedStartY * originalHeight;
                        const cropW = (normalizedEndX - normalizedStartX) * originalWidth;
                        const cropH = (normalizedEndY - normalizedStartY) * originalHeight;
                        
                        tempCanvas.width = cropW;
                        tempCanvas.height = cropH;
                        
                        tempCtx.clearRect(0, 0, cropW, cropH);
                        tempCtx.drawImage(
                            this.state.image,
                            cropX, cropY, cropW, cropH,
                            0, 0, cropW, cropH
                        );
                        
                        if (this.state.removeBackground && targetRgb) {
                            const imgData = tempCtx.getImageData(0, 0, cropW, cropH);
                            const data = imgData.data;
                            const { r: tr, g: tg, b: tb } = targetRgb;
                            
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                
                                const distSq = (r - tr) ** 2 + (g - tg) ** 2 + (b - tb) ** 2;
                                
                                if (distSq <= toleranceSq) {
                                    data[i + 3] = 0;
                                }
                            }
                            tempCtx.putImageData(imgData, 0, 0);
                        }
                        
                        const dataURL = tempCanvas.toDataURL('image/png');
                        const index = r * (allLinesX.length - 1) + c + 1;
                        croppedImages.push({ dataURL, index });
                        
                        const imgPreview = document.createElement('img');
                        imgPreview.src = dataURL;
                        
                        if (this.state.removeBackground) {
                            imgPreview.style.backgroundImage = 'repeating-conic-gradient(#ccc 0% 25%, transparent 0% 50%)';
                            imgPreview.style.backgroundSize = '16px 16px';
                        }
                        imgPreview.classList.add('w-full', 'h-auto', 'rounded-lg', 'shadow-md', 'object-cover');
                        
                        const div = document.createElement('div');
                        div.classList.add('relative', 'group', 'overflow-hidden', 'flex', 'flex-col', 'items-center', 'p-2', 'bg-gray-100', 'rounded-xl', 'shadow-md');
                        
                        div.innerHTML = `<span class="absolute top-0 left-0 bg-black/60 text-white text-xs px-2 py-0.5 rounded-br-xl z-10">#${index}</span>`;
                        div.appendChild(imgPreview);
                        
                        const downloadBtn = document.createElement('a');
                        downloadBtn.href = dataURL;
                        downloadBtn.download = `cropped_image_${index}.png`;
                        downloadBtn.textContent = 'ğŸ’¾ å–®å¼µä¸‹è¼‰';
                        downloadBtn.classList.add('mt-3', 'w-full', 'text-center', 'px-3', 'py-1.5', 'bg-blue-500', 'hover:bg-blue-600', 'text-white', 'font-medium', 'rounded-lg', 'text-sm', 'transition');
                        div.appendChild(downloadBtn);
                        
                        this.elements.previewGrid.appendChild(div);
                    }
                }
                
                this.elements.cropButton.textContent = 'è™•ç†ä¸­... (æ­£åœ¨æ‰“åŒ… ZIP)';
                
                const zip = new JSZip();
                croppedImages.forEach(imgData => {
                    const base64Data = imgData.dataURL.split(',')[1];
                    zip.file(`cropped_image_${imgData.index}.png`, base64Data, { base64: true });
                });
                
                try {
                    const content = await zip.generateAsync({ type: "blob" });
                    
                    if (this.elements.bulkDownloadLink.href && this.elements.bulkDownloadLink.href.startsWith('blob:')) {
                        URL.revokeObjectURL(this.elements.bulkDownloadLink.href);
                    }
                    
                    const url = URL.createObjectURL(content);
                    this.elements.bulkDownloadLink.href = url;
                    this.elements.bulkDownloadLink.classList.remove('hidden');
                    
                    this.showMessage(`å‰ªè£å®Œæˆï¼å…±ç”¢ç”Ÿ ${croppedImages.length} å¼µåœ–ç‰‡ã€‚è«‹é»æ“ŠæŒ‰éˆ•é€²è¡Œä¸‹è¼‰ã€‚`, 'bg-green-100 text-green-700');
                    this.playSound('E6', '4n');
                } catch (error) {
                    console.error("ç”Ÿæˆ ZIP å¤±æ•—:", error);
                    this.showMessage("å‰ªè£å®Œæˆï¼Œä½† ZIP æ‰“åŒ…å¤±æ•—ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°éŒ¯èª¤è¨Šæ¯ã€‚", 'bg-red-100 text-red-700');
                }
                
                this.elements.cropButton.textContent = 'âœ‚ï¸ é‡æ–°å‰ªè£';
                this.elements.cropButton.disabled = false;
            },
            
            // =========================================================
            // è¨­å®šå„²å­˜èˆ‡è¼‰å…¥
            // =========================================================
            saveSettings() {
                const settings = {
                    mode: this.state.mode,
                    cropCount: this.state.cropCount,
                    rows: this.state.grid.rows,
                    cols: this.state.grid.cols,
                    removeBackground: this.state.removeBackground,
                    bgTargetColor: this.state.bgTargetColor,
                    bgTolerance: this.state.bgTolerance,
                    lines: this.state.lines
                };
                localStorage.setItem('cropToolSettings', JSON.stringify(settings));
                this.showMessage('è¨­å®šå·²å„²å­˜ï¼', 'bg-green-100 text-green-700');
                this.playSound('G5', '16n');
            },
            

            loadSettings() {
                const saved = localStorage.getItem('cropToolSettings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        
                        // å¥—ç”¨æ¨¡å¼
                        this.state.mode = settings.mode || 'auto';
                        if (this.state.mode === 'custom') {
                            document.getElementById('modeCustom').checked = true;
                            this.elements.autoModeInputs.classList.add('hidden');
                            this.elements.customModeInputs.classList.remove('hidden');
                        } else {
                            document.getElementById('modeAuto').checked = true;
                            this.elements.customModeInputs.classList.add('hidden');
                            this.elements.autoModeInputs.classList.remove('hidden');
                        }
                        
                        // å¥—ç”¨åƒæ•¸
                        if (settings.cropCount) {
                            this.elements.cropCountInput.value = settings.cropCount;
                            this.state.cropCount = settings.cropCount;
                        }
                        if (settings.rows) {
                            this.elements.rowsInput.value = settings.rows;
                        }
                        if (settings.cols) {
                            this.elements.colsInput.value = settings.cols;
                        }
                        
                        // å¥—ç”¨å»èƒŒè¨­å®š
                        if (settings.removeBackground !== undefined) {
                            this.elements.removeBackgroundCheckbox.checked = settings.removeBackground;
                            this.state.removeBackground = settings.removeBackground;
                            if (settings.removeBackground) {
                                this.elements.bgRemovalControls.classList.remove('hidden');
                            }
                        }
                        if (settings.bgTargetColor) {
                            this.elements.targetColorInput.value = settings.bgTargetColor;
                            this.state.bgTargetColor = settings.bgTargetColor;
                        }
                        if (settings.bgTolerance !== undefined) {
                            this.elements.toleranceInput.value = settings.bgTolerance;
                            this.state.bgTolerance = settings.bgTolerance;
                            this.elements.toleranceValue.textContent = `${settings.bgTolerance}%`;
                        }
                        
                        // é¡¯ç¤ºè¨­å®šæŒ‰éˆ•
                        this.elements.saveSettingsBtn.classList.remove('hidden');
                        this.elements.loadSettingsBtn.classList.remove('hidden');
                        
                        this.showMessage('å·²è¼‰å…¥ä¸Šæ¬¡çš„è¨­å®šï¼', 'bg-blue-100 text-blue-700');
                        this.playSound('C5', '16n');
                    } catch (error) {
                        console.error('è¼‰å…¥è¨­å®šå¤±æ•—:', error);
                    }
                } else {
                    // é¡¯ç¤ºè¨­å®šæŒ‰éˆ•ï¼ˆå³ä½¿æ²’æœ‰å„²å­˜çš„è¨­å®šï¼‰
                    this.elements.saveSettingsBtn.classList.remove('hidden');
                    this.elements.loadSettingsBtn.classList.remove('hidden');
                }
            },
            
            // =========================================================
            // éµç›¤å¿«æ·éµ
            // =========================================================
            handleKeyboard(e) {
                // Ctrl+Z: å¾©åŸ
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    this.undo();
                }
                
                // Ctrl+Y æˆ– Ctrl+Shift+Z: é‡åš
                if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                    e.preventDefault();
                    this.redo();
                }
                
                // Ctrl+S: å„²å­˜è¨­å®š
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    this.saveSettings();
                }
                
                // æ–¹å‘éµå¾®èª¿æ ¼ç·šï¼ˆç•¶æœ‰é¸ä¸­çš„æ ¼ç·šæ™‚ï¼‰
                if (this.state.draggingLine && ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                    e.preventDefault();
                    const step = e.shiftKey ? 0.01 : 0.005; // Shift åŠ é€Ÿ
                    
                    if (this.state.draggingLine.type === 'vertical') {
                        if (e.key === 'ArrowLeft') {
                            this.state.lines.vertical[this.state.draggingLine.index] = 
                                Math.max(CONFIG.LINE_MIN_POSITION, this.state.lines.vertical[this.state.draggingLine.index] - step);
                        } else if (e.key === 'ArrowRight') {
                            this.state.lines.vertical[this.state.draggingLine.index] = 
                                Math.min(CONFIG.LINE_MAX_POSITION, this.state.lines.vertical[this.state.draggingLine.index] + step);
                        }
                    } else if (this.state.draggingLine.type === 'horizontal') {
                        if (e.key === 'ArrowUp') {
                            this.state.lines.horizontal[this.state.draggingLine.index] = 
                                Math.max(CONFIG.LINE_MIN_POSITION, this.state.lines.horizontal[this.state.draggingLine.index] - step);
                        } else if (e.key === 'ArrowDown') {
                            this.state.lines.horizontal[this.state.draggingLine.index] = 
                                Math.min(CONFIG.LINE_MAX_POSITION, this.state.lines.horizontal[this.state.draggingLine.index] + step);
                        }
                    }
                    
                    this.state.lines.vertical.sort((a, b) => a - b);
                    this.state.lines.horizontal.sort((a, b) => a - b);
                    this.drawCanvas();
                }
            },
            
            // =========================================================
            // è¦–çª—å¤§å°èª¿æ•´
            // =========================================================
            handleResize() {
                if (this.state.image) {
                    const containerWidth = document.getElementById('canvas-container').clientWidth;
                    const canvasWidth = containerWidth;
                    const canvasHeight = canvasWidth / this.state.imgRatio;
                    this.elements.canvas.style.width = `${canvasWidth}px`;
                    this.elements.canvas.style.height = `${canvasHeight}px`;
                    this.drawCanvas();
                }
            },
            
            // =========================================================
            // è¨Šæ¯é¡¯ç¤º
            // =========================================================
            showMessage(text, className) {
                this.elements.messageBox.textContent = text;
                this.elements.messageBox.className = `mt-4 p-3 rounded-lg text-sm text-center font-medium ${className}`;
                this.elements.messageBox.classList.remove('hidden');
                
                // 5 ç§’å¾Œè‡ªå‹•éš±è—
                setTimeout(() => {
                    this.elements.messageBox.classList.add('hidden');
                }, 5000);
            }
        };
        
        // =========================================================
        // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–
        // =========================================================
        document.addEventListener('DOMContentLoaded', () => {
            CropTool.init();
        });
        
        // å…¨åŸŸå‡½å¼ï¼ˆä¾› HTML onclick ä½¿ç”¨ï¼‰
        window.CropTool = CropTool;
    </script>
</body>
</html>

