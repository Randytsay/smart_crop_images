<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ–ç‰‡æ™ºæ…§å‰ªè£å·¥å…·</title>
    <!-- è¼‰å…¥ Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è¼‰å…¥ Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- è¼‰å…¥ JSZip for creating ZIP archives -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* è‡ªå®šç¾©æ¼¸å±¤èƒŒæ™¯ */
        .app-bg {
            background: linear-gradient(135deg, #4A90E2 0%, #50E3C2 100%);
            min-height: 100vh;
        }
        /* ç¢ºä¿å…§å®¹é ä¸Šå°é½Š */
        .content-container {
            padding-top: 20px;
        }
        /* Canvas å®¹å™¨æ¨£å¼ */
        #canvas-container {
            max-width: 100%;
            height: auto;
            position: relative;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .file-upload-label {
            transition: all 0.2s;
        }
        .file-upload-label:hover {
            box-shadow: 0 4px 15px rgba(50, 255, 200, 0.4);
            transform: translateY(-2px);
        }
        /* æ‹–æ›³é è¦½æ¡†æ¨£å¼ */
        #drag-preview {
            position: absolute;
            z-index: 50;
            pointer-events: none;
            display: none;
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #4A90E2;
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        #previewCanvas {
            max-width: 100px;
            max-height: 100px;
            display: block;
        }
        /* ç„¡éšœç¤™ï¼šè¢å¹•é–±è®€å™¨å°ˆç”¨ */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'Noto Sans TC', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="font-sans app-bg">
    
    <!-- å°è¦½åˆ— -->
    <header class="bg-white/90 shadow-md sticky top-0 z-10">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-3 flex justify-between items-center">
            <h1 class="text-xl sm:text-2xl font-bold text-gray-800">åœ–ç‰‡æ™ºæ…§å‰ªè£å·¥å…·</h1>
            <div class="flex items-center space-x-4">
                <button id="saveSettingsBtn" title="å„²å­˜ç•¶å‰è¨­å®š" class="hidden text-blue-600 hover:text-blue-800 transition duration-150 ease-in-out p-2 rounded-full hover:bg-blue-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                </button>
                <button id="loadSettingsBtn" title="è¼‰å…¥ä¸Šæ¬¡è¨­å®š" class="hidden text-green-600 hover:text-green-800 transition duration-150 ease-in-out p-2 rounded-full hover:bg-green-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                </button>
            </div>
        </div>
    </header>

    <!-- ä¸»è¦å…§å®¹å€ -->
    <main class="content-container max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-12">
        
        <!-- æª”æ¡ˆä¸Šå‚³èˆ‡æ§åˆ¶å€ -->
        <div id="controls" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">æ­¥é©Ÿ 1: ä¸Šå‚³åœ–ç‰‡èˆ‡è¨­å®š</h2>
            
            <!-- A. åœ–ç‰‡ä¸Šå‚³ -->
            <label for="imageUpload" class="file-upload-label cursor-pointer flex items-center justify-center p-4 border-2 border-dashed border-blue-400 bg-blue-50/50 rounded-lg text-blue-700 font-medium mb-4">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                <span>ğŸ“‚ é»æ“Šæˆ–æ‹–æ›³åœ–ç‰‡åˆ°æ­¤è™•ä¸Šå‚³</span>
            </label>
            <input type="file" id="imageUpload" accept="image/*" class="hidden" aria-label="ä¸Šå‚³åœ–ç‰‡æª”æ¡ˆ">

            <!-- ä¸Šå‚³é€²åº¦é¡¯ç¤ºå€ -->
            <div id="upload-progress-container" class="mt-3 hidden">
                <p id="upload-status" class="text-sm text-gray-700 mb-1">æº–å‚™ä¸­...</p>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>

            <!-- B. åƒæ•¸è¨­å®š -->
            <div id="settings-area" class="mt-4 p-4 border rounded-lg bg-gray-50 hidden">
                
                <!-- å¿«é€Ÿç¯„æœ¬é¸æ“‡ -->
                <div class="mb-4 p-3 bg-gradient-to-r from-purple-50 to-pink-50 rounded-lg border border-purple-200">
                    <label class="block text-sm font-bold text-gray-800 mb-2">ğŸš€ å¿«é€Ÿç¯„æœ¬ï¼š</label>
                    <div class="flex flex-wrap gap-2">
                        <button onclick="CropTool.applyTemplate(1, 2)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">1Ã—2 ä¸Šä¸‹</button>
                        <button onclick="CropTool.applyTemplate(2, 1)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">2Ã—1 å·¦å³</button>
                        <button onclick="CropTool.applyTemplate(2, 2)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">2Ã—2 å››å®®æ ¼</button>
                        <button onclick="CropTool.applyTemplate(3, 3)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">3Ã—3 ä¹å®®æ ¼</button>
                        <button onclick="CropTool.applyTemplate(4, 4)" class="px-3 py-1.5 bg-white hover:bg-purple-100 text-purple-700 font-medium rounded-lg shadow-sm transition">4Ã—4 åå…­å®®æ ¼</button>
                    </div>
                </div>

                <!-- å‰ªè£æ¨¡å¼åˆ‡æ› -->
                <label class="block text-sm font-medium text-gray-700 mb-2">å‰ªè£æ¨¡å¼:</label>
                <div class="flex space-x-4 mb-4">
                    <label class="flex items-center">
                        <input type="radio" name="cropMode" value="auto" checked id="modeAuto" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500" onclick="CropTool.switchMode('auto')">
                        <span class="ml-2 text-sm text-gray-700">è‡ªå‹•å„ªåŒ– (ç¸½å¼µæ•¸)</span>
                    </label>
                    <label class="flex items-center">
                        <input type="radio" name="cropMode" value="custom" id="modeCustom" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500" onclick="CropTool.switchMode('custom')">
                        <span class="ml-2 text-sm text-gray-700">è‡ªè¨‚æ ¼ç·š (è¡Œåˆ—æ•¸)</span>
                    </label>
                </div>

                <!-- è‡ªå‹•æ¨¡å¼è¼¸å…¥ -->
                <div id="auto-mode-inputs">
                    <label for="cropCount" class="block text-sm font-medium text-gray-700 mb-1">
                        è¼¸å…¥æœŸæœ›çš„å‰ªè£çµæœç¸½å¼µæ•¸ (N)ï¼š
                    </label>
                    <input type="number" id="cropCount" value="4" min="1" max="100" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="ä¾‹å¦‚ï¼š4">
                </div>

                <!-- è‡ªè¨‚æ¨¡å¼è¼¸å…¥ -->
                <div id="custom-mode-inputs" class="hidden">
                    <div class="flex space-x-4">
                        <div class="flex-1">
                            <label for="rowsInput" class="block text-sm font-medium text-gray-700 mb-1">
                                åˆ—æ•¸ (R)ï¼š
                            </label>
                            <input type="number" id="rowsInput" value="2" min="1" max="20" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <div class="flex-1">
                            <label for="colsInput" class="block text-sm font-medium text-gray-700 mb-1">
                                è¡Œæ•¸ (C)ï¼š
                            </label>
                            <input type="number" id="colsInput" value="2" min="1" max="20" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    </div>
                </div>

                <!-- å»èƒŒé¸é … -->
                <div class="mt-4 p-4 bg-blue-50 rounded-lg border border-blue-100">
                    <label class="block text-sm font-bold text-gray-800 mb-2">
                        é€²éšåŠŸèƒ½ï¼šèƒŒæ™¯å»é™¤
                    </label>
                    
                    <div class="flex items-center space-x-2 mb-3">
                        <input type="checkbox" id="removeBackground" class="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                        <span class="text-sm font-medium text-gray-800">å•Ÿç”¨è‰²å½©å»èƒŒ (é©åˆç´”è‰²èƒŒæ™¯)</span>
                    </div>

                    <!-- é€²éšå»èƒŒæ§åˆ¶é … -->
                    <div id="bg-removal-controls" class="hidden pl-6 border-l-2 border-blue-200 space-y-3">
                        <div class="flex items-center space-x-3">
                            <label for="targetColor" class="text-sm text-gray-700">é¸æ“‡è¦å»é™¤çš„é¡è‰²ï¼š</label>
                            <input type="color" id="targetColor" value="#ffffff" class="h-8 w-14 cursor-pointer border rounded">
                        </div>
                        
                        <div>
                            <div class="flex justify-between">
                                <label for="tolerance" class="text-sm text-gray-700">å®¹è¨±åº¦ (Tolerance)ï¼š</label>
                                <span id="tolerance-value" class="text-sm font-medium text-blue-600">15%</span>
                            </div>
                            <input type="range" id="tolerance" min="0" max="100" value="15" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer mt-1">
                            <p class="text-xs text-gray-500 mt-1">æ•¸å€¼è¶Šé«˜ï¼Œå»é™¤çš„é¡è‰²ç¯„åœè¶Šå»£ (åŒ…å«é™°å½±æˆ–ç›¸è¿‘è‰²)ã€‚</p>
                        </div>
                    </div>
                </div>

                <p id="grid-info" class="text-sm text-gray-500 mt-2">ç›®å‰åŠƒåˆ†ç‚º 2 åˆ— x 2 è¡Œã€‚</p>
            </div>
            
            <div id="message-box" class="mt-4 p-3 rounded-lg text-sm text-center font-medium hidden"></div>

        </div>

        <!-- C. åœ–ç‰‡é è¦½èˆ‡ç·¨è¼¯å€ -->
        <div id="canvas-wrapper" class="hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-white">æ­¥é©Ÿ 2: èª¿æ•´å‰ªè£æ ¼ç·š (æ‹–æ›³æ ¼ç·š)</h2>
                <div class="flex space-x-2">
                    <button id="undoBtn" class="px-3 py-1.5 bg-white/90 hover:bg-white text-gray-700 font-medium rounded-lg shadow-sm transition flex items-center space-x-1" title="å¾©åŸä¸Šä¸€æ­¥ (Ctrl+Z)">
                        <span>â†¶</span>
                        <span class="hidden sm:inline">å¾©åŸ</span>
                    </button>
                    <button id="redoBtn" class="px-3 py-1.5 bg-white/90 hover:bg-white text-gray-700 font-medium rounded-lg shadow-sm transition flex items-center space-x-1" title="é‡åš (Ctrl+Y)">
                        <span>â†·</span>
                        <span class="hidden sm:inline">é‡åš</span>
                    </button>
                    <button id="resetBtn" class="px-3 py-1.5 bg-white/90 hover:bg-white text-gray-700 font-medium rounded-lg shadow-sm transition flex items-center space-x-1" title="é‡ç½®ç‚ºå‡åˆ†æ ¼ç·š">
                        <span>âŸ²</span>
                        <span class="hidden sm:inline">é‡ç½®</span>
                    </button>
                </div>
            </div>
            <div id="canvas-container">
                <canvas id="cropCanvas" tabindex="0" role="img" aria-label="å¯æ‹–æ›³èª¿æ•´çš„å‰ªè£æ ¼ç·šé è¦½"></canvas>
                <!-- æ‹–æ›³æ™‚çš„é è¦½ç•«é¢ -->
                <div id="drag-preview">
                    <canvas id="previewCanvas"></canvas>
                    <div id="preview-info" class="text-xs text-center mt-1 font-medium text-gray-700"></div>
                </div>
            </div>
        </div>

        <!-- D. åŸ·è¡Œèˆ‡ä¸‹è¼‰ -->
        <div id="action-area" class="mt-8 hidden">
            <h2 class="text-xl font-semibold text-white mb-4">æ­¥é©Ÿ 3: å®Œæˆå‰ªè£</h2>
            <button id="cropButton" class="w-full sm:w-auto px-8 py-3 text-lg font-semibold text-white rounded-xl shadow-lg transition duration-300 ease-in-out 
                bg-pink-500 hover:bg-pink-600 focus:outline-none focus:ring-4 focus:ring-pink-300" aria-describedby="crop-description">
                âœ‚ï¸ é–‹å§‹å‰ªè£
            </button>
            <div id="crop-description" class="sr-only">é»æ“Šæ­¤æŒ‰éˆ•å°‡æ ¹æ“šç•¶å‰æ ¼ç·šè¨­å®šå‰ªè£åœ–ç‰‡</div>
            
            <div id="download-area" class="mt-6 p-4 bg-white rounded-xl shadow-lg hidden">
                <h3 class="text-lg font-medium text-gray-700 mb-3">å‰ªè£çµæœé è¦½ï¼š</h3>
                
                <!-- ä¸€éµæ‰“åŒ…ä¸‹è¼‰æŒ‰éˆ• -->
                <a id="bulkDownloadLink" href="#" 
                   class="mb-4 px-4 py-2 bg-green-500 text-white font-semibold rounded-xl shadow-md hover:bg-green-600 transition duration-150 ease-in-out hidden text-center cursor-pointer inline-block" 
                   download="smart_crop_images.zip" title="ä¸‹è¼‰æ‰€æœ‰å‰ªè£å¾Œçš„åœ–ç‰‡">
                    â¬‡ï¸ ä¸‹è¼‰æ‰€æœ‰åœ–ç‰‡ (ZIP)
                </a>

                <!-- é è¦½ç¶²æ ¼ -->
                <div id="preview-grid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 mt-4">
                    <!-- å‰ªè£å¾Œçš„å°åœ–å°‡é¡¯ç¤ºåœ¨é€™è£¡ -->
                </div>
            </div>
        </div>

    </main>

    <!-- ç‰ˆæ¬Šå®£å‘Š -->
    <footer class="bg-white/90 py-4 mt-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center text-sm text-gray-600">
            @Randy
        </div>
    </footer>

    <script>
        // =========================================================
        // é…ç½®å¸¸æ•¸
        // =========================================================
        const CONFIG = {
            // äº’å‹•è¨­å®š
            HIT_AREA: 15,              // æ ¼ç·šé»æ“Šå®¹éŒ¯ç¯„åœï¼ˆpxï¼‰
            LINE_MIN_POSITION: 0.05,   // æ ¼ç·šæœ€å°ä½ç½®ï¼ˆ5%ï¼‰
            LINE_MAX_POSITION: 0.95,   // æ ¼ç·šæœ€å¤§ä½ç½®ï¼ˆ95%ï¼‰
            
            // æª”æ¡ˆé™åˆ¶
            MAX_FILE_SIZE: 20 * 1024 * 1024,  // 20MB
            MAX_CROPS: 100,                    // æœ€å¤šå‰ªè£æ•¸é‡
            
            // å»èƒŒè¨­å®š
            DEFAULT_BG_COLOR: '#ffffff',
            DEFAULT_TOLERANCE: 15,
            
            // UI è¨­å®š
            PREVIEW_MAX_SIZE: 120,
            LINE_WIDTH: 2,
            DOT_SIZE: 8,
            
            // æ”¯æ´çš„æª”æ¡ˆæ ¼å¼
            VALID_FILE_TYPES: ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp']
        };

        // =========================================================
        // ä¸»è¦æ‡‰ç”¨ç¨‹å¼ç‰©ä»¶
        // =========================================================
        const CropTool = {
            // DOM å…ƒç´ 
            elements: {},
            
            // ç‹€æ…‹
            state: {
                image: null,
                imgRatio: 1, 
                lines: {
                    vertical: [], 
                    horizontal: [] 
                },
                draggingLine: null, 
                grid: { rows: 2, cols: 2 },
                cropCount: 4,
                removeBackground: false,
                bgTargetColor: CONFIG.DEFAULT_BG_COLOR,
                bgTolerance: CONFIG.DEFAULT_TOLERANCE,
                mode: 'auto'
            },
            
            // æ­·å²è¨˜éŒ„
            history: {
                states: [],
                currentIndex: -1,
                
                push(lines) {
                    this.states = this.states.slice(0, this.currentIndex + 1);
                    this.states.push(JSON.parse(JSON.stringify(lines)));
                    this.currentIndex++;
                    CropTool.updateHistoryButtons();
                },
                
                undo() {
                    if (this.currentIndex > 0) {
                        this.currentIndex--;
                        CropTool.updateHistoryButtons();
                        return this.states[this.currentIndex];
                    }
                    return null;
                },
                
                redo() {
                    if (this.currentIndex < this.states.length - 1) {
                        this.currentIndex++;
                        CropTool.updateHistoryButtons();
                        return this.states[this.currentIndex];
                    }
                    return null;
                },
                
                clear() {
                    this.states = [];
                    this.currentIndex = -1;
                    CropTool.updateHistoryButtons();
                }
            },
            
            // éŸ³æ•ˆ
            synth: null,
            
            // =========================================================
            // åˆå§‹åŒ–
            // =========================================================
            init() {
                this.cacheElements();
                this.bindEvents();
                this.initAudio();
                this.loadSettings();
            },
            
            cacheElements() {
                const $ = (id) => document.getElementById(id);
                
                this.elements = {
                    canvas: $('cropCanvas'),
                    imageUpload: $('imageUpload'),
                    cropCountInput: $('cropCount'),
                    gridInfo: $('grid-info'),
                    cropButton: $('cropButton'),
                    previewGrid: $('preview-grid'),
                    settingsArea: $('settings-area'),
                    canvasWrapper: $('canvas-wrapper'),
                    actionArea: $('action-area'),
                    messageBox: $('message-box'),
                    bulkDownloadLink: $('bulkDownloadLink'),
                    removeBackgroundCheckbox: $('removeBackground'),
                    bgRemovalControls: $('bg-removal-controls'),
                    targetColorInput: $('targetColor'),
                    toleranceInput: $('tolerance'),
                    toleranceValue: $('tolerance-value'),
                    rowsInput: $('rowsInput'),
                    colsInput: $('colsInput'),
                    autoModeInputs: $('auto-mode-inputs'),
                    customModeInputs: $('custom-mode-inputs'),
                    dragPreview: $('drag-preview'),
                    previewCanvas: $('previewCanvas'),
                    previewInfo: $('preview-info'),
                    uploadProgressContainer: $('upload-progress-container'),
                    uploadStatus: $('upload-status'),
                    progressBar: $('progress-bar'),
                    uploadLabel: document.querySelector('.file-upload-label'),
                    undoBtn: $('undoBtn'),
                    redoBtn: $('redoBtn'),
                    resetBtn: $('resetBtn'),
                    saveSettingsBtn: $('saveSettingsBtn'),
                    loadSettingsBtn: $('loadSettingsBtn'),
                    downloadArea: $('download-area')
                };
                
                this.elements.ctx = this.elements.canvas.getContext('2d');
                this.elements.previewCtx = this.elements.previewCanvas.getContext('2d');
            },
            
            bindEvents() {
                // åœ–ç‰‡ä¸Šå‚³
                this.elements.imageUpload.addEventListener('change', (e) => this.handleImageUpload(e));
                
                // æ‹–æ”¾ä¸Šå‚³
                this.elements.uploadLabel.addEventListener('dragover', (e) => this.handleDragOver(e));
                this.elements.uploadLabel.addEventListener('dragleave', () => this.handleDragLeave());
                this.elements.uploadLabel.addEventListener('drop', (e) => this.handleDrop(e));
                
                // åƒæ•¸è®Šæ›´
                this.elements.cropCountInput.addEventListener('input', () => {
                    if (this.state.mode === 'auto') this.updateGrid();
                });
                this.elements.rowsInput.addEventListener('input', () => this.updateGrid());
                this.elements.colsInput.addEventListener('input', () => this.updateGrid());
                
                // å»èƒŒé¸é …
                this.elements.removeBackgroundCheckbox.addEventListener('change', () => this.toggleBackgroundRemoval());
                this.elements.targetColorInput.addEventListener('input', (e) => {
                    this.state.bgTargetColor = e.target.value;
                });
                this.elements.toleranceInput.addEventListener('input', (e) => {
                    this.state.bgTolerance = parseInt(e.target.value);
                    this.elements.toleranceValue.textContent = `${this.state.bgTolerance}%`;
                });
                
                // Canvas äº’å‹•
                this.elements.canvas.addEventListener('mousedown', (e) => this.handleStart(e.clientX, e.clientY));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', () => this.handleEnd());
                
                this.elements.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleStart(touch.clientX, touch.clientY);
                });
                this.elements.canvas.addEventListener('touchmove', (e) => {
                    if (this.state.draggingLine) {
                        const touch = e.touches[0];
                        this.handleMove(touch.clientX, touch.clientY);
                    }
                });
                this.elements.canvas.addEventListener('touchend', () => this.handleEnd());
                
                // å‰ªè£æŒ‰éˆ•
                this.elements.cropButton.addEventListener('click', () => this.executeCrop());
                
                // æ­·å²è¨˜éŒ„æŒ‰éˆ•
                this.elements.undoBtn.addEventListener('click', () => this.undo());
                this.elements.redoBtn.addEventListener('click', () => this.redo());
                this.elements.resetBtn.addEventListener('click', () => this.resetGrid());
                
                // è¨­å®šå„²å­˜/è¼‰å…¥
                this.elements.saveSettingsBtn.addEventListener('click', () => this.saveSettings());
                this.elements.loadSettingsBtn.addEventListener('click', () => this.loadSettings());
                
                // éµç›¤å¿«æ·éµ
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));
                
                // è¦–çª—å¤§å°èª¿æ•´
                window.addEventListener('resize', () => this.handleResize());
            },
            
            initAudio() {
                document.addEventListener('click', () => {
                    if (!this.synth) {
                        try {
                            this.synth = new Tone.Synth().toDestination();
                        } catch (error) {
                            console.error("Tone.js åˆå§‹åŒ–å¤±æ•—:", error);
                        }
                    }
                }, { once: true });
            },
            
            // =========================================================
            // éŸ³æ•ˆæ’­æ”¾
            // =========================================================
            playSound(note, duration = '8n', time = '+0.05') {
                if (this.synth) {
                    try {
                        this.synth.triggerAttackRelease(note, duration, time);
                    } catch (e) {
                        console.warn("æ’­æ”¾éŸ³æ•ˆå¤±æ•—:", e);
                    }
                }
            },
            
            // =========================================================
            // åœ–ç‰‡ä¸Šå‚³è™•ç†
            // =========================================================
            handleImageUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // æª”æ¡ˆå¤§å°æª¢æŸ¥
                if (file.size > CONFIG.MAX_FILE_SIZE) {
                    this.showMessage(`æª”æ¡ˆéå¤§ï¼è«‹ä¸Šå‚³å°æ–¼ ${CONFIG.MAX_FILE_SIZE / 1024 / 1024}MB çš„åœ–ç‰‡ã€‚`, 'bg-red-100 text-red-700');
                    return;
                }
                
                // æª”æ¡ˆé¡å‹æª¢æŸ¥
                if (!CONFIG.VALID_FILE_TYPES.includes(file.type)) {
                    this.showMessage('ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼ï¼è«‹ä¸Šå‚³ JPGã€PNGã€WebPã€GIF æˆ– BMPã€‚', 'bg-red-100 text-red-700');
                    return;
                }
                
                this.loadImage(file);
            },
            
            loadImage(file) {
                this.elements.uploadProgressContainer.classList.remove('hidden');
                this.elements.uploadStatus.textContent = 'æº–å‚™ä¸­...';
                this.elements.progressBar.style.width = '10%';
                
                this.elements.settingsArea.classList.remove('hidden');
                this.elements.canvasWrapper.classList.remove('hidden');
                this.elements.actionArea.classList.remove('hidden');
                this.elements.previewGrid.innerHTML = '';
                this.elements.downloadArea.classList.add('hidden');
                this.elements.bulkDownloadLink.classList.add('hidden');
                
                const reader = new FileReader();
                
                reader.onloadstart = () => {
                    this.elements.uploadStatus.textContent = 'æª”æ¡ˆè®€å–ä¸­...';
                    this.elements.progressBar.style.width = '30%';
                };
                
                reader.onprogress = (event) => {
                    if (event.lengthComputable) {
                        const percent = (event.loaded / event.total) * 100;
                        this.elements.uploadStatus.textContent = `æª”æ¡ˆè®€å–ä¸­: ${percent.toFixed(0)}%`;
                        this.elements.progressBar.style.width = `${Math.min(percent, 80)}%`;
                    }
                };
                
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        this.state.image = img;
                        this.state.imgRatio = img.width / img.height;
                        
                        setTimeout(() => {
                            this.elements.uploadStatus.textContent = 'åœ–ç‰‡è§£ç¢¼å®Œæˆï¼Œæ­£åœ¨ç¹ªè£½ä¸­...';
                            this.elements.progressBar.style.width = '90%';
                            
                            const containerWidth = document.getElementById('canvas-container').clientWidth || 600;
                            const canvasWidth = containerWidth;
                            const canvasHeight = canvasWidth / this.state.imgRatio;
                            
                            this.elements.canvas.width = img.width;
                            this.elements.canvas.height = img.height;
                            this.elements.canvas.style.width = `${canvasWidth}px`;
                            this.elements.canvas.style.height = `${canvasHeight}px`;
                            
                            this.history.clear();
                            this.updateGrid();
                            this.playSound('A4');
                            
                            this.elements.uploadStatus.textContent = 'å®Œæˆï¼';
                            this.elements.progressBar.style.width = '100%';
                            setTimeout(() => {
                                this.elements.uploadProgressContainer.classList.add('hidden');
                                this.elements.progressBar.style.width = '0%';
                            }, 500);
                        }, 0);
                    };
                    
                    img.onerror = () => {
                        this.showMessage("åœ–ç‰‡è§£ç¢¼å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ ¼å¼æ˜¯å¦æ­£ç¢ºã€‚", 'bg-red-100 text-red-700');
                        this.elements.uploadProgressContainer.classList.add('hidden');
                    };
                    
                    img.src = event.target.result;
                };
                
                reader.onerror = () => {
                    this.showMessage("æª”æ¡ˆè®€å–å¤±æ•—ï¼", 'bg-red-100 text-red-700');
                    this.elements.uploadProgressContainer.classList.add('hidden');
                };
                
                reader.readAsDataURL(file);
            },
            
            // =========================================================
            // æ‹–æ”¾è™•ç†
            // =========================================================
            handleDragOver(e) {
                e.preventDefault();
                this.elements.uploadLabel.classList.add('border-green-600', 'bg-green-50/50');
            },
            
            handleDragLeave() {
                this.elements.uploadLabel.classList.remove('border-green-600', 'bg-green-50/50');
            },
            
            handleDrop(e) {
                e.preventDefault();
                this.elements.uploadLabel.classList.remove('border-green-600', 'bg-green-50/50');
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    this.elements.imageUpload.files = e.dataTransfer.files;
                    this.handleImageUpload({ target: this.elements.imageUpload });
                }
            },
            
            // =========================================================
            // æ ¼ç·šè¨ˆç®—èˆ‡æ›´æ–°
            // =========================================================
            calculateOptimalGrid(N) {
                if (N <= 0) return { rows: 1, cols: 1 };
                
                let bestR = 1;
                let bestC = N;
                let minDiff = N;
                
                for (let r = 1; r * r <= N; r++) {
                    if (N % r === 0) {
                        const c = N / r;
                        if (Math.abs(r - c) < minDiff) {
                            minDiff = Math.abs(r - c);
                            bestR = r;
                            bestC = c;
                        }
                    }
                }
                
                if (minDiff === N) {
                    for (let r = 1; r <= N; r++) {
                        const c = Math.ceil(N / r);
                        const diff = Math.abs(r - c);
                        if (diff < minDiff || (diff === minDiff && r * c >= N && r * c < bestR * bestC)) {
                            minDiff = diff;
                            bestR = r;
                            bestC = c;
                        }
                    }
                }
                
                if (this.state.imgRatio > 1 && bestR > bestC) {
                    return { rows: bestC, cols: bestR };
                } else if (this.state.imgRatio < 1 && bestC > bestR) {
                    return { rows: bestC, cols: bestR };
                }
                
                return { rows: bestR, cols: bestC };
            },
            
            updateGrid() {
                if (!this.state.image) return;
                
                let rows, cols;
                
                if (this.state.mode === 'custom') {
                    rows = parseInt(this.elements.rowsInput.value) || 1;
                    cols = parseInt(this.elements.colsInput.value) || 1;
                    rows = Math.max(1, Math.min(rows, 20));
                    cols = Math.max(1, Math.min(cols, 20));
                    this.elements.rowsInput.value = rows;
                    this.elements.colsInput.value = cols;
                } else {
                    const N = parseInt(this.elements.cropCountInput.value) || 1;
                    this.state.cropCount = Math.max(1, Math.min(N, CONFIG.MAX_CROPS));
                    this.elements.cropCountInput.value = this.state.cropCount;
                    
                    const grid = this.calculateOptimalGrid(this.state.cropCount);
                    rows = grid.rows;
                    cols = grid.cols;
                }
                
                // æª¢æŸ¥ç¸½æ•¸é™åˆ¶
                if (rows * cols > CONFIG.MAX_CROPS) {
                    this.showMessage(`å‰ªè£æ•¸é‡éå¤šï¼æœ€å¤šæ”¯æ´ ${CONFIG.MAX_CROPS} å¼µã€‚`, 'bg-yellow-100 text-yellow-700');
                    rows = Math.min(rows, 10);
                    cols = Math.min(cols, 10);
                }
                
                this.state.grid.rows = rows;
                this.state.grid.cols = cols;
                
                this.elements.gridInfo.textContent = `ç›®å‰åŠƒåˆ†ç‚º ${rows} åˆ— x ${cols} è¡Œ (å…± ${rows * cols} å¡Š)ã€‚`;
                
                // é‡æ–°åˆå§‹åŒ–æ ¼ç·šï¼ˆå‡åˆ†ï¼‰
                this.state.lines.vertical = [];
                for (let i = 1; i < cols; i++) {
                    this.state.lines.vertical.push(i / cols);
                }
                
                this.state.lines.horizontal = [];
                for (let i = 1; i < rows; i++) {
                    this.state.lines.horizontal.push(i / rows);
                }
                
                this.history.clear();
                this.history.push(this.state.lines);
                this.drawCanvas();
            },
            
            // =========================================================
            // Canvas ç¹ªè£½
            // =========================================================
            drawCanvas() {
                if (!this.state.image) return;
                
                const width = this.elements.canvas.width;
                const height = this.elements.canvas.height;
                
                this.elements.ctx.clearRect(0, 0, width, height);
                this.elements.ctx.drawImage(this.state.image, 0, 0, width, height);
                
                this.elements.ctx.beginPath();
                this.elements.ctx.strokeStyle = this.state.draggingLine ? '#ff0000' : '#FFD700';
                this.elements.ctx.lineWidth = CONFIG.LINE_WIDTH;
                
                this.state.lines.vertical.forEach(normalizedX => {
                    const x = normalizedX * width;
                    this.elements.ctx.moveTo(x, 0);
                    this.elements.ctx.lineTo(x, height);
                });
                
                this.state.lines.horizontal.forEach(normalizedY => {
                    const y = normalizedY * height;
                    this.elements.ctx.moveTo(0, y);
                    this.elements.ctx.lineTo(width, y);
                });
                
                this.elements.ctx.stroke();
                
                // ç¹ªè£½æ‹–æ›³é»
                this.elements.ctx.fillStyle = '#4A90E2';
                const dotSize = CONFIG.DOT_SIZE;
                
                this.state.lines.vertical.forEach(normalizedX => {
                    const x = normalizedX * width;
                    this.elements.ctx.fillRect(x - dotSize / 2, height / 2 - dotSize / 2, dotSize, dotSize);
                });
                
                this.state.lines.horizontal.forEach(normalizedY => {
                    const y = normalizedY * height;
                    this.elements.ctx.fillRect(width / 2 - dotSize / 2, y - dotSize / 2, dotSize, dotSize);
                });
            },
            
            // =========================================================
            // äº’å‹•è™•ç†
            // =========================================================
            getLineUnderCursor(clientX, clientY) {
                const rect = this.elements.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                for (let i = 0; i < this.state.lines.vertical.length; i++) {
                    const lineX = this.state.lines.vertical[i] * rect.width;
                    if (Math.abs(x - lineX) < CONFIG.HIT_AREA) {
                        if (this.state.image && x >= 0 && x <= rect.width) {
                            return { type: 'vertical', index: i };
                        }
                    }
                }
                
                for (let i = 0; i < this.state.lines.horizontal.length; i++) {
                    const lineY = this.state.lines.horizontal[i] * rect.height;
                    if (Math.abs(y - lineY) < CONFIG.HIT_AREA) {
                        if (this.state.image && y >= 0 && y <= rect.height) {
                            return { type: 'horizontal', index: i };
                        }
                    }
                }
                
                return null;
            },
            
            handleStart(clientX, clientY) {
                const targetLine = this.getLineUnderCursor(clientX, clientY);
                if (targetLine) {
                    this.state.draggingLine = targetLine;
                    this.elements.canvas.style.cursor = targetLine.type === 'vertical' ? 'col-resize' : 'row-resize';
                    this.drawCanvas();
                    this.elements.dragPreview.style.display = 'block';
                } else {
                    this.state.draggingLine = null;
                    this.elements.canvas.style.cursor = 'default';
                    this.elements.dragPreview.style.display = 'none';
                }
            },
            
            handleMouseMove(e) {
                if (this.state.draggingLine) {
                    this.handleMove(e.clientX, e.clientY);
                } else if (this.state.image) {
                    const targetLine = this.getLineUnderCursor(e.clientX, e.clientY);
                    if (targetLine) {
                        this.elements.canvas.style.cursor = targetLine.type === 'vertical' ? 'col-resize' : 'row-resize';
                    } else {
                        this.elements.canvas.style.cursor = 'default';
                    }
                }
            },
            
            handleMove(clientX, clientY) {
                if (!this.state.draggingLine || !this.state.image) return;
                
                const rect = this.elements.canvas.getBoundingClientRect();
                let newValue;
                
                if (this.state.draggingLine.type === 'vertical') {
                    const x = clientX - rect.left;
                    newValue = Math.min(CONFIG.LINE_MAX_POSITION, Math.max(CONFIG.LINE_MIN_POSITION, x / rect.width));
                    this.state.lines.vertical[this.state.draggingLine.index] = newValue;
                } else {
                    const y = clientY - rect.top;
                    newValue = Math.min(CONFIG.LINE_MAX_POSITION, Math.max(CONFIG.LINE_MIN_POSITION, y / rect.height));
                    this.state.lines.horizontal[this.state.draggingLine.index] = newValue;
                }
                
                this.state.lines.vertical.sort((a, b) => a - b);
                this.state.lines.horizontal.sort((a, b) => a - b);
                
                this.drawCanvas();
                this.drawPreview(clientX, clientY);
            },
            
            handleEnd() {
                if (this.state.draggingLine) {
                    this.history.push(this.state.lines);
                }
                this.state.draggingLine = null;
                this.elements.canvas.style.cursor = 'default';
                this.elements.dragPreview.style.display = 'none';
                this.drawCanvas();
            },
            
            drawPreview(clientX, clientY) {
                if (!this.state.draggingLine || !this.state.image) return;
                
                const lineType = this.state.draggingLine.type;
                const lineIndex = this.state.draggingLine.index;
                
                const allLinesX = [0, ...this.state.lines.vertical, 1].sort((a, b) => a - b);
                const allLinesY = [0, ...this.state.lines.horizontal, 1].sort((a, b) => a - b);
                
                let normalizedStartX, normalizedEndX, normalizedStartY, normalizedEndY;
                let currentWidth, currentHeight;
                
                if (lineType === 'vertical') {
                    normalizedStartX = allLinesX[lineIndex];
                    normalizedEndX = allLinesX[lineIndex + 1];
                    normalizedStartY = allLinesY[0];
                    normalizedEndY = allLinesY[1] || 1;
                    
                    currentWidth = (normalizedEndX - normalizedStartX) * this.state.image.width;
                    currentHeight = (normalizedEndY - normalizedStartY) * this.state.image.height;
                } else {
                    normalizedStartX = allLinesX[0];
                    normalizedEndX = allLinesX[1] || 1;
                    normalizedStartY = allLinesY[lineIndex];
                    normalizedEndY = allLinesY[lineIndex + 1];
                    
                    currentWidth = (normalizedEndX - normalizedStartX) * this.state.image.width;
                    currentHeight = (normalizedEndY - normalizedStartY) * this.state.image.height;
                }
                
                const cropX = normalizedStartX * this.state.image.width;
                const cropY = normalizedStartY * this.state.image.height;
                const cropW = (normalizedEndX - normalizedStartX) * this.state.image.width;
                const cropH = (normalizedEndY - normalizedStartY) * this.state.image.height;
                
                this.elements.previewCanvas.width = cropW;
                this.elements.previewCanvas.height = cropH;
                
                this.elements.previewCtx.clearRect(0, 0, cropW, cropH);
                this.elements.previewCtx.drawImage(
                    this.state.image,
                    cropX, cropY, cropW, cropH,
                    0, 0, cropW, cropH
                );
                
                // æ›´æ–°é è¦½æ¡†ä½ç½®ï¼ˆé˜²æ­¢è¶…å‡ºè¦–çª—ï¼‰
                this.updatePreviewPosition(clientX, clientY);
                
                this.elements.previewInfo.textContent = `W: ${currentWidth.toFixed(0)}px / H: ${currentHeight.toFixed(0)}px`;
                
                const maxSize = CONFIG.PREVIEW_MAX_SIZE;
                if (cropW > cropH) {
                    this.elements.previewCanvas.style.width = `${maxSize}px`;
                    this.elements.previewCanvas.style.height = `${(cropH / cropW) * maxSize}px`;
                } else {
                    this.elements.previewCanvas.style.height = `${maxSize}px`;
                    this.elements.previewCanvas.style.width = `${(cropW / cropH) * maxSize}px`;
                }
            },
            
            updatePreviewPosition(clientX, clientY) {
                const previewRect = this.elements.dragPreview.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                let left = clientX + 20;
                let top = clientY + 20;
                
                if (left + previewRect.width > viewportWidth) {
                    left = clientX - previewRect.width - 20;
                }
                
                if (top + previewRect.height > viewportHeight) {
                    top = clientY - previewRect.height - 20;
                }
                
                this.elements.dragPreview.style.left = `${left + window.scrollX}px`;
                this.elements.dragPreview.style.top = `${top + window.scrollY}px`;
            },
            
            // =========================================================
            // æ­·å²è¨˜éŒ„åŠŸèƒ½
            // =========================================================
            undo() {
                const previousState = this.history.undo();
                if (previousState) {
                    this.state.lines = JSON.parse(JSON.stringify(previousState));
                    this.drawCanvas();
                    this.playSound('F4', '16n');
                }
            },
            
            redo() {
                const nextState = this.history.redo();
                if (nextState) {
                    this.state.lines = JSON.parse(JSON.stringify(nextState));
                    this.drawCanvas();
                    this.playSound('A4', '16n');
                }
            },
            
            resetGrid() {
                if (!this.state.image) return;
                this.updateGrid();
                this.playSound('C4', '16n');
                this.showMessage('å·²é‡ç½®ç‚ºå‡åˆ†æ ¼ç·š', 'bg-blue-100 text-blue-700');
            },
            
            updateHistoryButtons() {
                this.elements.undoBtn.disabled = this.history.currentIndex <= 0;
                this.elements.redoBtn.disabled = this.history.currentIndex >= this.history.states.length - 1;
                
                if (this.elements.undoBtn.disabled) {
                    this.elements.undoBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    this.elements.undoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                
                if (this.elements.redoBtn.disabled) {
                    this.elements.redoBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    this.elements.redoBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            },
            
            // =========================================================
            // æ¨¡å¼åˆ‡æ›èˆ‡ç¯„æœ¬
            // =========================================================
            switchMode(mode) {
                this.state.mode = mode;
                if (mode === 'custom') {
                    this.elements.autoModeInputs.classList.add('hidden');
                    this.elements.customModeInputs.classList.remove('hidden');
                } else {
                    this.elements.customModeInputs.classList.add('hidden');
                    this.elements.autoModeInputs.classList.remove('hidden');
                }
                this.updateGrid();
            },
            
            applyTemplate(rows, cols) {
                document.getElementById('modeCustom').checked = true;
                this.switchMode('custom');
                this.elements.rowsInput.value = rows;
                this.elements.colsInput.value = cols;
                this.updateGrid();
                this.playSound('E5', '16n');
            },
            
            // =========================================================
            // å»èƒŒåŠŸèƒ½
            // =========================================================
            toggleBackgroundRemoval() {
                this.state.removeBackground = this.elements.removeBackgroundCheckbox.checked;
                if (this.state.removeBackground) {
                    this.elements.bgRemovalControls.classList.remove('hidden');
                } else {
                    this.elements.bgRemovalControls.classList.add('hidden');
                }
            },
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },
            
            // =========================================================
            // å‰ªè£åŸ·è¡Œ
            // =========================================================
            async executeCrop() {
                if (!this.state.image) {
                    this.showMessage("è«‹å…ˆä¸Šå‚³åœ–ç‰‡ï¼", 'bg-red-100 text-red-700');
                    return;
                }
                
                if (typeof JSZip === 'undefined') {
                    this.showMessage("JSZip å‡½å¼åº«æœªè¼‰å…¥ï¼Œç„¡æ³•åŸ·è¡Œæ‰“åŒ…ä¸‹è¼‰ã€‚", 'bg-red-100 text-red-700');
                    return;
                }
                
                this.playSound('C6');
                this.elements.cropButton.disabled = true;
                this.elements.bulkDownloadLink.classList.add('hidden');
                this.elements.cropButton.textContent = 'è™•ç†ä¸­... (æ­£åœ¨å‰ªè£)';
                this.elements.previewGrid.innerHTML = '';
                this.elements.downloadArea.classList.remove('hidden');
                
                const allLinesX = [0, ...this.state.lines.vertical, 1].sort((a, b) => a - b);
                const allLinesY = [0, ...this.state.lines.horizontal, 1].sort((a, b) => a - b);
                
                const originalWidth = this.state.image.width;
                const originalHeight = this.state.image.height;
                const croppedImages = [];
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                let targetRgb = null;
                let toleranceSq = 0;
                if (this.state.removeBackground) {
                    targetRgb = this.hexToRgb(this.state.bgTargetColor);
                    const tol = this.state.bgTolerance * 2.55;
                    toleranceSq = tol * tol * 3;
                }
                
                for (let r = 0; r < allLinesY.length - 1; r++) {
                    for (let c = 0; c < allLinesX.length - 1; c++) {
                        const normalizedStartX = allLinesX[c];
                        const normalizedEndX = allLinesX[c + 1];
                        const normalizedStartY = allLinesY[r];
                        const normalizedEndY = allLinesY[r + 1];
                        
                        const cropX = normalizedStartX * originalWidth;
                        const cropY = normalizedStartY * originalHeight;
                        const cropW = (normalizedEndX - normalizedStartX) * originalWidth;
                        const cropH = (normalizedEndY - normalizedStartY) * originalHeight;
                        
                        tempCanvas.width = cropW;
                        tempCanvas.height = cropH;
                        
                        tempCtx.clearRect(0, 0, cropW, cropH);
                        tempCtx.drawImage(
                            this.state.image,
                            cropX, cropY, cropW, cropH,
                            0, 0, cropW, cropH
                        );
                        
                        if (this.state.removeBackground && targetRgb) {
                            const imgData = tempCtx.getImageData(0, 0, cropW, cropH);
                            const data = imgData.data;
                            const { r: tr, g: tg, b: tb } = targetRgb;
                            
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                
                                const distSq = (r - tr) ** 2 + (g - tg) ** 2 + (b - tb) ** 2;
                                
                                if (distSq <= toleranceSq) {
                                    data[i + 3] = 0;
                                }
                            }
                            tempCtx.putImageData(imgData, 0, 0);
                        }
                        
                        const dataURL = tempCanvas.toDataURL('image/png');
                        const index = r * (allLinesX.length - 1) + c + 1;
                        croppedImages.push({ dataURL, index });
                        
                        const imgPreview = document.createElement('img');
                        imgPreview.src = dataURL;
                        
                        if (this.state.removeBackground) {
                            imgPreview.style.backgroundImage = 'repeating-conic-gradient(#ccc 0% 25%, transparent 0% 50%)';
                            imgPreview.style.backgroundSize = '16px 16px';
                        }
                        imgPreview.classList.add('w-full', 'h-auto', 'rounded-lg', 'shadow-md', 'object-cover');
                        
                        const div = document.createElement('div');
                        div.classList.add('relative', 'group', 'overflow-hidden', 'flex', 'flex-col', 'items-center', 'p-2', 'bg-gray-100', 'rounded-xl', 'shadow-md');
                        
                        div.innerHTML = `<span class="absolute top-0 left-0 bg-black/60 text-white text-xs px-2 py-0.5 rounded-br-xl z-10">#${index}</span>`;
                        div.appendChild(imgPreview);
                        
                        const downloadBtn = document.createElement('a');
                        downloadBtn.href = dataURL;
                        downloadBtn.download = `cropped_image_${index}.png`;
                        downloadBtn.textContent = 'ğŸ’¾ å–®å¼µä¸‹è¼‰';
                        downloadBtn.classList.add('mt-3', 'w-full', 'text-center', 'px-3', 'py-1.5', 'bg-blue-500', 'hover:bg-blue-600', 'text-white', 'font-medium', 'rounded-lg', 'text-sm', 'transition');
                        div.appendChild(downloadBtn);
                        
                        this.elements.previewGrid.appendChild(div);
                    }
                }
                
                this.elements.cropButton.textContent = 'è™•ç†ä¸­... (æ­£åœ¨æ‰“åŒ… ZIP)';
                
                const zip = new JSZip();
                croppedImages.forEach(imgData => {
                    const base64Data = imgData.dataURL.split(',')[1];
                    zip.file(`cropped_image_${imgData.index}.png`, base64Data, { base64: true });
                });
                
                try {
                    const content = await zip.generateAsync({ type: "blob" });
                    
                    if (this.elements.bulkDownloadLink.href && this.elements.bulkDownloadLink.href.startsWith('blob:')) {
                        URL.revokeObjectURL(this.elements.bulkDownloadLink.href);
                    }
                    
                    const url = URL.createObjectURL(content);
                    this.elements.bulkDownloadLink.href = url;
                    this.elements.bulkDownloadLink.classList.remove('hidden');
                    
                    this.showMessage(`å‰ªè£å®Œæˆï¼å…±ç”¢ç”Ÿ ${croppedImages.length} å¼µåœ–ç‰‡ã€‚è«‹é»æ“ŠæŒ‰éˆ•é€²è¡Œä¸‹è¼‰ã€‚`, 'bg-green-100 text-green-700');
                    this.playSound('E6', '4n');
                } catch (error) {
                    console.error("ç”Ÿæˆ ZIP å¤±æ•—:", error);
                    this.showMessage("å‰ªè£å®Œæˆï¼Œä½† ZIP æ‰“åŒ…å¤±æ•—ã€‚è«‹æª¢æŸ¥æ§åˆ¶å°éŒ¯èª¤è¨Šæ¯ã€‚", 'bg-red-100 text-red-700');
                }
                
                this.elements.cropButton.textContent = 'âœ‚ï¸ é‡æ–°å‰ªè£';
                this.elements.cropButton.disabled = false;
            },
            
            // =========================================================
            // è¨­å®šå„²å­˜èˆ‡è¼‰å…¥
            // =========================================================
            saveSettings() {
                const settings = {
                    mode: this.state.mode,
                    cropCount: this.state.cropCount,
                    rows: this.state.grid.rows,
                    cols: this.state.grid.cols,
                    removeBackground: this.state.removeBackground,
                    bgTargetColor: this.state.bgTargetColor,
                    bgTolerance: this.state.bgTolerance,
                    lines: this.state.lines
                };
                localStorage.setItem('cropToolSettings', JSON.stringify(settings));
                this.showMessage('è¨­å®šå·²å„²å­˜ï¼', 'bg-green-100 text-green-700');
                this.playSound('G5', '16n');
            },
            

            loadSettings() {
                const saved = localStorage.getItem('cropToolSettings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        
                        // å¥—ç”¨æ¨¡å¼
                        this.state.mode = settings.mode || 'auto';
                        if (this.state.mode === 'custom') {
                            document.getElementById('modeCustom').checked = true;
                            this.elements.autoModeInputs.classList.add('hidden');
                            this.elements.customModeInputs.classList.remove('hidden');
                        } else {
                            document.getElementById('modeAuto').checked = true;
                            this.elements.customModeInputs.classList.add('hidden');
                            this.elements.autoModeInputs.classList.remove('hidden');
                        }
                        
                        // å¥—ç”¨åƒæ•¸
                        if (settings.cropCount) {
                            this.elements.cropCountInput.value = settings.cropCount;
                            this.state.cropCount = settings.cropCount;
                        }
                        if (settings.rows) {
                            this.elements.rowsInput.value = settings.rows;
                        }
                        if (settings.cols) {
                            this.elements.colsInput.value = settings.cols;
                        }
                        
                        // å¥—ç”¨å»èƒŒè¨­å®š
                        if (settings.removeBackground !== undefined) {
                            this.elements.removeBackgroundCheckbox.checked = settings.removeBackground;
                            this.state.removeBackground = settings.removeBackground;
                            if (settings.removeBackground) {
                                this.elements.bgRemovalControls.classList.remove('hidden');
                            }
                        }
                        if (settings.bgTargetColor) {
                            this.elements.targetColorInput.value = settings.bgTargetColor;
                            this.state.bgTargetColor = settings.bgTargetColor;
                        }
                        if (settings.bgTolerance !== undefined) {
                            this.elements.toleranceInput.value = settings.bgTolerance;
                            this.state.bgTolerance = settings.bgTolerance;
                            this.elements.toleranceValue.textContent = `${settings.bgTolerance}%`;
                        }
                        
                        // é¡¯ç¤ºè¨­å®šæŒ‰éˆ•
                        this.elements.saveSettingsBtn.classList.remove('hidden');
                        this.elements.loadSettingsBtn.classList.remove('hidden');
                        
                        this.showMessage('å·²è¼‰å…¥ä¸Šæ¬¡çš„è¨­å®šï¼', 'bg-blue-100 text-blue-700');
                        this.playSound('C5', '16n');
                    } catch (error) {
                        console.error('è¼‰å…¥è¨­å®šå¤±æ•—:', error);
                    }
                } else {
                    // é¡¯ç¤ºè¨­å®šæŒ‰éˆ•ï¼ˆå³ä½¿æ²’æœ‰å„²å­˜çš„è¨­å®šï¼‰
                    this.elements.saveSettingsBtn.classList.remove('hidden');
                    this.elements.loadSettingsBtn.classList.remove('hidden');
                }
            },
            
            // =========================================================
            // éµç›¤å¿«æ·éµ
            // =========================================================
            handleKeyboard(e) {
                // Ctrl+Z: å¾©åŸ
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    this.undo();
                }
                
                // Ctrl+Y æˆ– Ctrl+Shift+Z: é‡åš
                if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                    e.preventDefault();
                    this.redo();
                }
                
                // Ctrl+S: å„²å­˜è¨­å®š
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    this.saveSettings();
                }
                
                // æ–¹å‘éµå¾®èª¿æ ¼ç·šï¼ˆç•¶æœ‰é¸ä¸­çš„æ ¼ç·šæ™‚ï¼‰
                if (this.state.draggingLine && ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
                    e.preventDefault();
                    const step = e.shiftKey ? 0.01 : 0.005; // Shift åŠ é€Ÿ
                    
                    if (this.state.draggingLine.type === 'vertical') {
                        if (e.key === 'ArrowLeft') {
                            this.state.lines.vertical[this.state.draggingLine.index] = 
                                Math.max(CONFIG.LINE_MIN_POSITION, this.state.lines.vertical[this.state.draggingLine.index] - step);
                        } else if (e.key === 'ArrowRight') {
                            this.state.lines.vertical[this.state.draggingLine.index] = 
                                Math.min(CONFIG.LINE_MAX_POSITION, this.state.lines.vertical[this.state.draggingLine.index] + step);
                        }
                    } else if (this.state.draggingLine.type === 'horizontal') {
                        if (e.key === 'ArrowUp') {
                            this.state.lines.horizontal[this.state.draggingLine.index] = 
                                Math.max(CONFIG.LINE_MIN_POSITION, this.state.lines.horizontal[this.state.draggingLine.index] - step);
                        } else if (e.key === 'ArrowDown') {
                            this.state.lines.horizontal[this.state.draggingLine.index] = 
                                Math.min(CONFIG.LINE_MAX_POSITION, this.state.lines.horizontal[this.state.draggingLine.index] + step);
                        }
                    }
                    
                    this.state.lines.vertical.sort((a, b) => a - b);
                    this.state.lines.horizontal.sort((a, b) => a - b);
                    this.drawCanvas();
                }
            },
            
            // =========================================================
            // è¦–çª—å¤§å°èª¿æ•´
            // =========================================================
            handleResize() {
                if (this.state.image) {
                    const containerWidth = document.getElementById('canvas-container').clientWidth;
                    const canvasWidth = containerWidth;
                    const canvasHeight = canvasWidth / this.state.imgRatio;
                    this.elements.canvas.style.width = `${canvasWidth}px`;
                    this.elements.canvas.style.height = `${canvasHeight}px`;
                    this.drawCanvas();
                }
            },
            
            // =========================================================
            // è¨Šæ¯é¡¯ç¤º
            // =========================================================
            showMessage(text, className) {
                this.elements.messageBox.textContent = text;
                this.elements.messageBox.className = `mt-4 p-3 rounded-lg text-sm text-center font-medium ${className}`;
                this.elements.messageBox.classList.remove('hidden');
                
                // 5 ç§’å¾Œè‡ªå‹•éš±è—
                setTimeout(() => {
                    this.elements.messageBox.classList.add('hidden');
                }, 5000);
            }
        };
        
        // =========================================================
        // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–
        // =========================================================
        document.addEventListener('DOMContentLoaded', () => {
            CropTool.init();
        });
        
        // å…¨åŸŸå‡½å¼ï¼ˆä¾› HTML onclick ä½¿ç”¨ï¼‰
        window.CropTool = CropTool;
    </script>
</body>
</html>
